<?xml version="1.0" encoding="utf-8"?>
<doc>
<assembly><name>FSharp.DataFrame</name></assembly>
<members>
<member name="T:AssemblyInfo">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="F:ExtCore.Collections.ExtCore.Collections.LazyList`1.undefinedValue">
<summary>
 The status for undefined values.
</summary>
</member>
<member name="">

</member>
<member name="M:ExtCore.Collections.LazyList`1.op_PlusPlus(ExtCore.Collections.LazyList{`0},ExtCore.Collections.LazyList{`0})">
<summary>
 Appends the second LazyList to the end of the first.
</summary>
</member>
<member name="">

</member>
<member name="P:ExtCore.Collections.LazyList`1.IsEmpty">
<summary>
 Test if a list is empty.
 Forces the evaluation of the first element of the stream if it is not already evaluated.
</summary>
</member>
<member name="P:ExtCore.Collections.LazyList`1.Empty">
<summary>
 The empty LazyList.
</summary>
</member>
<member name="M:ExtCore.Collections.LazyList`1.TryHeadTail">
<summary>
 Get the first cell of the list.
</summary>
</member>
<member name="M:ExtCore.Collections.LazyList`1.ToSeq">
<summary>
 Creates a sequence which enumerates the values in the LazyList.
</summary>
</member>
<member name="M:ExtCore.Collections.LazyList`1.Tail">
<summary>
 Return the list corresponding to the remaining items in the sequence.
 Forces the evaluation of the first cell of the list if it is not already evaluated.
</summary>
</member>
<member name="M:ExtCore.Collections.LazyList`1.Head">
<summary>
 Return the first element of the list.
 Forces the evaluation of the first cell of the list if it is not already evaluated.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:ExtCore.Collections.LazyList`1.Delayed(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,ExtCore.Collections.LazyList{`0}})">
<summary>
 Return a list that is -- in effect -- the list returned by the given computation.
 The given computation is not executed until the first element on the list is consumed.
</summary>
</member>
<member name="">

</member>
<member name="M:ExtCore.Collections.LazyList`1.ConsDelayed(`0,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,ExtCore.Collections.LazyList{`0}})">
<summary>
 Return a new list which on consumption contains the given item 
 followed by the list returned by the given computation.
</summary>
</member>
<member name="M:ExtCore.Collections.LazyList`1.Cons(`0,ExtCore.Collections.LazyList{`0})">
<summary>
 Return a new list which contains the given item followed by the given list.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:ExtCore.Collections.LazyList`1">
<summary>
 LazyLists are possibly-infinite, cached sequences.  See also IEnumerable/Seq for
 uncached sequences. LazyLists normally involve delayed computations without 
 side-effects.  The results of these computations are cached and evaluations will be 
 performed only once for each element of the lazy list.  In contrast, for sequences 
 (IEnumerable) recomputation happens each time an enumerator is created and the sequence 
 traversed.

 LazyLists can represent cached, potentially-infinite computations.  Because they are 
 cached they may cause memory leaks if some active code or data structure maintains a 
 live reference to the head of an infinite or very large lazy list while iterating it, 
 or if a reference is maintained after the list is no longer required.

 Lazy lists may be matched using the LazyList.Cons and LazyList.Nil active patterns. 
 These may force the computation of elements of the list.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:ExtCore.Collections.LazyListPatterns">
<summary>
 Active patterns for deconstructing lazy lists.
</summary>
</member>
<member name="M:ExtCore.Collections.LazyListModule.ToArray``1(ExtCore.Collections.LazyList{``0})">
<summary>
 Build an array from the given LazyList. This function will eagerly
 evaluate the entire list (and thus may not terminate).
</summary>
</member>
<member name="M:ExtCore.Collections.LazyListModule.ToList``1(ExtCore.Collections.LazyList{``0})">
<summary>
 Build a non-lazy list from the given collection. This function will eagerly
 evaluate the entire list (and thus may not terminate).
</summary>
</member>
<member name="M:ExtCore.Collections.LazyListModule.ToSeq``1(ExtCore.Collections.LazyList{``0})">
<summary>
 Return a view of the collection as an enumerable object.
</summary>
</member>
<member name="M:ExtCore.Collections.LazyListModule.OfArray``1(``0[])">
<summary>
 Create a LazyList containing the elements of the given array.
</summary>
</member>
<member name="M:ExtCore.Collections.LazyListModule.copyFrom``1(System.Int32,``0[])">
<summary>
 Creates a LazyList from an array by copying elements from the array into the LazyList.
</summary>
</member>
<member name="M:ExtCore.Collections.LazyListModule.OfList``1(Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Create a LazyList containing the elements of the given list.
</summary>
</member>
<member name="M:ExtCore.Collections.LazyListModule.OfSeq``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
 Build a LazyList from the given sequence of elements.
</summary>
</member>
<member name="">

</member>
<member name="M:ExtCore.Collections.LazyListModule.Iterate``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit},ExtCore.Collections.LazyList{``0})">
<summary>
 Apply the given function to each element of the collection.
</summary>
</member>
<member name="M:ExtCore.Collections.LazyListModule.Skip``1(System.Int32,ExtCore.Collections.LazyList{``0})">
<summary>
 Return the list which on consumption will skip the first &apos;count&apos; elements of the input list.
</summary>
</member>
<member name="">

</member>
<member name="M:ExtCore.Collections.LazyListModule.Take``1(System.Int32,ExtCore.Collections.LazyList{``0})">
<summary>
 Return the list which on consumption will consist of
 at most &apos;count&apos; elements of the input list.
</summary>
</member>
<member name="M:ExtCore.Collections.LazyListModule.Scan``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}},``0,ExtCore.Collections.LazyList{``1})">
<summary>
 Return a new list consisting of the results of applying the
 given accumulating function to successive elements of the list.
</summary>
</member>
<member name="">

</member>
<member name="M:ExtCore.Collections.LazyListModule.Filter``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},ExtCore.Collections.LazyList{``0})">
<summary>
 Return a new collection which on consumption will consist of only the
 elements of the collection for which the given predicate returns &quot;true&quot;.
</summary>
</member>
<member name="M:ExtCore.Collections.LazyListModule.Zip``1(ExtCore.Collections.LazyList{``0},ExtCore.Collections.LazyList{``0})">
<summary>
 Return the list which contains on demand the pair of elements of the first and second list.
</summary>
</member>
<member name="M:ExtCore.Collections.LazyListModule.Map2``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},ExtCore.Collections.LazyList{``0},ExtCore.Collections.LazyList{``1})">
<summary>
 Build a new collection whose elements are the results of applying the given function
 to the corresponding elements of the two collections pairwise.
</summary>
</member>
<member name="M:ExtCore.Collections.LazyListModule.Map``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},ExtCore.Collections.LazyList{``0})">
<summary>
 Build a new collection whose elements are the results of applying
 the given function to each of the elements of the collection.
</summary>
</member>
<member name="M:ExtCore.Collections.LazyListModule.Unfold``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{System.Tuple{``1,``0}}},``0)">
<summary>
 Return a list that contains the elements returned by the given computation.
 The given computation is not executed until the first element on the list is
 consumed.  The given argument is passed to the computation.  Subsequent elements
 in the list are generated by again applying the residual &apos;b to the computation.
</summary>
</member>
<member name="M:ExtCore.Collections.LazyListModule.Find``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},ExtCore.Collections.LazyList{``0})">
<summary>
 Return the first element for which the given function returns &lt;c&gt;true&lt;/c&gt;.
 Raise &lt;c&gt;KeyNotFoundException&lt;/c&gt; if no such element exists.
</summary>
</member>
<member name="M:ExtCore.Collections.LazyListModule.TryFind``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},ExtCore.Collections.LazyList{``0})">
<summary>
 Apply the given function to successive elements of the list, returning the first
 result where function returns &lt;c&gt;Some(x)&lt;/c&gt; for some x.
 If the function never returns true, &apos;None&apos; is returned.
</summary>
</member>
<member name="M:ExtCore.Collections.LazyListModule.Concat``1(ExtCore.Collections.LazyList{ExtCore.Collections.LazyList{``0}})">
<summary>
 Return the list which contains on demand the list of elements of the list of lazy lists.
</summary>
</member>
<member name="">

</member>
<member name="M:ExtCore.Collections.LazyListModule.Append``1(ExtCore.Collections.LazyList{``0},ExtCore.Collections.LazyList{``0})">
<summary>
 Return the list which contains on demand the elements of the
 first list followed by the elements of the second list.
</summary>
</member>
<member name="M:ExtCore.Collections.LazyListModule.Repeat``1(``0)">
<summary>
 Return the list which on consumption will consist of an
 infinite sequence of the given item.
</summary>
</member>
<member name="M:ExtCore.Collections.LazyListModule.Length``1(ExtCore.Collections.LazyList{``0})">
<summary>
 Return the length of the list.
</summary>
</member>
<member name="M:ExtCore.Collections.LazyListModule.lzy``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,ExtCore.Collections.LazyListCell{``0}})">
<summary>
 Alias for LazyList.CreateLazy.
</summary>
</member>
<member name="M:ExtCore.Collections.LazyListModule.consCell``1(``0,ExtCore.Collections.LazyList{``0})">
<summary>
 Returns a new LazyListCell created by adding a value to the end of the given LazyList.
 This is simply a curried form of the Cons constructor.
</summary>
</member>
<member name="M:ExtCore.Collections.LazyListModule.Singleton``1(``0)">
<summary>
 Creates a LazyList containing the given value.
</summary>
</member>
<member name="M:ExtCore.Collections.LazyListModule.Delayed``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,ExtCore.Collections.LazyList{``0}})">
<summary>
 Return a list that is -- in effect -- the list returned by the given computation.
 The given computation is not executed until the first element on the list is consumed.
</summary>
</member>
<member name="M:ExtCore.Collections.LazyListModule.ConsDelayed``1(``0,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,ExtCore.Collections.LazyList{``0}})">
<summary>
 Return a new list which on consumption contains the given item
 followed by the list returned by the given computation.
</summary>
</member>
<member name="M:ExtCore.Collections.LazyListModule.Cons``1(``0,ExtCore.Collections.LazyList{``0})">
<summary>
 Return a new list which contains the given item followed by the given list.
</summary>
</member>
<member name="M:ExtCore.Collections.LazyListModule.IsEmpty``1(ExtCore.Collections.LazyList{``0})">
<summary>
 Test if a list is empty.
 Forces the evaluation of the first element of the stream if it is not already evaluated.
</summary>
</member>
<member name="M:ExtCore.Collections.LazyListModule.Tail``1(ExtCore.Collections.LazyList{``0})">
<summary>
 Return the list corresponding to the remaining items in the sequence.
 Forces the evaluation of the first cell of the list if it is not already evaluated.
</summary>
</member>
<member name="M:ExtCore.Collections.LazyListModule.Head``1(ExtCore.Collections.LazyList{``0})">
<summary>
 Return the first element of the list.
 Forces the evaluation of the first cell of the list if it is not already evaluated.
</summary>
</member>
<member name="M:ExtCore.Collections.LazyListModule.TryGet``1(ExtCore.Collections.LazyList{``0})">
<summary>
 Get the first cell of the list.
</summary>
</member>
<member name="M:ExtCore.Collections.LazyListModule.Empty``1">
<summary>
 The empty LazyList.
</summary>
</member>
<member name="T:ExtCore.Collections.LazyListModule">
<summary>
 Functional operators on LazyLists.
</summary>
</member>
<member name="M:ExtCore.Collections.ExtCoreExtensions.RaiseArgumentOutOfRangeException``1(System.String,System.String)">
<summary>
 Raises a System.ArgumentOutOfRangeException.
</summary>
</member>
<member name="M:ExtCore.Collections.ExtCoreExtensions.CheckNonNull``1(System.String,``0)">
<summary>
 Determines if a reference is a null reference, and if it is, throws an ArgumentNullException.
</summary>
</member>
<member name="M:ExtCore.Collections.ExtCoreExtensions.IsNull``1(``0)">
<summary>
 Determines if a reference is a null reference.
</summary>
</member>
<member name="T:ExtCore.Collections.ExtCoreExtensions">

</member>
<member name="M:FSharp.DataFrame.Aggregation.WindowWhile``1(System.Func{``0,``0,System.Boolean})">
<summary>
 Aggregate data into floating windows where each window ends as soon
 as the specified function returns `false` when called with the 
 first key and the current key as arguments.

 ## Parameters

  - `condition` - A delegate that specifies when to end the current window
    (e.g. `(k1, k2) =&gt; k2 - k1 &lt; 10` means that the difference between keys
    in each window will be less than 10.
</summary>
</member>
<member name="M:FSharp.DataFrame.Aggregation.WindowSize``1(System.Int32,FSharp.DataFrame.Boundary)">
<summary>
 Aggregate data into floating windows of a specified size 
 and the provided handling of boundary elements.

 ## Parameters

  - `size` - Specifies the size of the floating window. Depending on the
    boundary behavior, the actual created windows may be smaller.
  - `boundary` - Specifies how to handle boundaries (when there is not
    enough data to create an entire window). 
</summary>
</member>
<member name="M:FSharp.DataFrame.Aggregation.ChunkWhile``1(System.Func{``0,``0,System.Boolean})">
<summary>
 Aggregate data into non-overlapping chunks where each chunk ends as soon
 as the specified function returns `false` when called with the 
 first key and the current key as arguments.

 ## Parameters

  - `condition` - A delegate that specifies when to end the current chunk
    (e.g. `(k1, k2) =&gt; k2 - k1 &lt; 10` means that the difference between keys
    in each chunk will be less than 10.
</summary>
</member>
<member name="M:FSharp.DataFrame.Aggregation.ChunkSize``1(System.Int32,FSharp.DataFrame.Boundary)">
<summary>
 Aggregate data into non-overlapping chunks of a specified size 
 and the provided handling of boundary elements.

 ## Parameters

  - `size` - Specifies the size of the floating window. Depending on the
    boundary behavior, the actual created windows may be smaller.
  - `boundary` - Specifies how to handle boundaries (when there is not
    enough data to create an entire window). 
</summary>
</member>
<member name="T:FSharp.DataFrame.Aggregation">
<summary>
 A non-generic type that simplifies the construction of `Aggregation&lt;K&gt;` values
 from C#. It provides methods for constructing different kinds of aggregation
 strategies for ordered series.
</summary>
</member>
<member name="T:FSharp.DataFrame.Aggregation`1.ChunkWhile">
<summary>
 Aggregate data into non-overlapping chunks where each chunk ends as soon
 as the specified function returns `false` when called with the 
 first key and the current key as arguments.
</summary>
</member>
<member name="T:FSharp.DataFrame.Aggregation`1.WindowWhile">
<summary>
 Aggregate data into floating windows where each window ends as soon
 as the specified function returns `false` when called with the 
 first key and the current key as arguments.
</summary>
</member>
<member name="T:FSharp.DataFrame.Aggregation`1.ChunkSize">
<summary>
 Aggregate data into non-overlapping chunks of a specified size 
 and the provided handling of boundary elements.
</summary>
</member>
<member name="T:FSharp.DataFrame.Aggregation`1.WindowSize">
<summary>
 Aggregate data into floating windows of a specified size 
 and the provided handling of boundary elements.
</summary>
</member>
<member name="T:FSharp.DataFrame.Aggregation`1">
<summary>
 Represents a strategy for aggregating data in an ordered series into data segments.
 To create a value of this type from C#, use the non-generic `Aggregation` type.
 Data can be aggregate using floating windows or chunks of a specified size or 
 by specifying a condition on two keys (i.e. end a window/chunk when the condition
 no longer holds).
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharp.DataFrame.Boundary">
<summary>
 Represents boundary behaviour for operations such as floating window. The type
 specifies whether incomplete windows (of smaller than required length) should be
 produced at the beginning (`AtBeginning`) or at the end (`AtEnding`) or
 skipped (`Skip`). For chunking, combinations are allowed too - to skip incomplete
 chunk at the beginning, use `Boundary.Skip ||| Boundary.AtBeginning`.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharp.DataFrame.DataSegmentKind">
<summary>
 Represents a kind of `DataSegment&lt;T&gt;`. See that type for more information.
</summary>
</member>
<member name="">

</member>
<member name="P:FSharp.DataFrame.DataSegment`1.Kind">
<summary>
 Return the kind of this segment
</summary>
</member>
<member name="P:FSharp.DataFrame.DataSegment`1.Data">
<summary>
 Returns the data associated with the segment
 (for boundary segment, this may be smaller than the required window size)
</summary>
</member>
<member name="M:FSharp.DataFrame.DataSegment`1.ToString">
<summary>
 Format data segment nicely
</summary>
</member>
<member name="T:FSharp.DataFrame.DataSegment`1">
<summary>
 Represents a segment of a series or sequence. The value is returned from 
 various functions that aggregate data into chunks or floating windows. The 
 `Complete` case represents complete segment (e.g. of the specified size) and
 `Boundary` represents segment at the boundary (e.g. smaller than the required
 size). 

 ## Example

 For example (using internal `windowed` function):

     open FSharp.DataFrame.Internal

     Seq.windowedWithBounds 3 Boundary.AtBeginning [ 1; 2; 3; 4 ]
     [fsi:  [| DataSegment(Incomplete, [| 1 |])         ]
     [fsi:       DataSegment(Incomplete, [| 1; 2 |])    ]
     [fsi:       DataSegment(Complete [| 1; 2; 3 |])    ]
     [fsi:       DataSegment(Complete [| 2; 3; 4 |]) |] ]

 If you do not need to distinguish the two cases, you can use the `Data` property
 to get the array representing the segment data.
</summary>
</member>
<member name="M:FSharp.DataFrame.DelayedSeries.Create``3(``0,``0,Microsoft.FSharp.Core.FSharpFunc{System.Tuple{``0,FSharp.DataFrame.Indices.BoundaryBehavior},Microsoft.FSharp.Core.FSharpFunc{System.Tuple{``0,FSharp.DataFrame.Indices.BoundaryBehavior},Microsoft.FSharp.Control.FSharpAsync{``1}}})">
<summary>
 An F#-friendly function that creates lazily loaded series. The method requires
 the overall range of the series (smallest and greatest key) and a function that
 loads the data. The function is called with two tuples that specify lower and upper
 boundary. It returns an asynchronous workflow that produces the data.

 ## Parameters
 
  - `min` - The smallest key that should be present in the created series.
  - `min` - The greatests key that should be present in the created series.
  - `loader` - A function which returns an asynchronous workflow that loads the data in a 
    specified range. The function is called with two tuples consisting of key and 
    `BoundaryBehavior` values. The keys specify lower and upper boundary and 
    `BoundaryBehavior` values can be either `Inclusive` or `Exclusive`.

 ## Remarks

 For more information see the [lazy data loading tutorial](../lazysource.html).
</summary>
</member>
<member name="M:FSharp.DataFrame.DelayedSeries.Create``2(``0,``0,System.Func{``0,FSharp.DataFrame.Indices.BoundaryBehavior,``0,FSharp.DataFrame.Indices.BoundaryBehavior,System.Threading.Tasks.Task{System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{``0,``1}}}})">
<summary>
 A C#-friendly function that creates lazily loaded series. The method requires
 the overall range of the series (smallest and greatest key) and a function that
 loads the data. In this overload, the function is a `Func` delegate taking 
 information about the requested range and returning `Task&lt;T&gt;` that produces the data.

 ## Parameters
 
  - `min` - The smallest key that should be present in the created series.
  - `min` - The greatests key that should be present in the created series.
  - `loader` - A delegate which returns a task that loads the data in a specified 
    range. The delegate is called with four arguments specifying the minimal and
    maximal key and two `BoundaryBehavior` values specifying whether the low and
    high ranges are inclusive or exclusive.

 ## Remarks

 For more information see the [lazy data loading tutorial](../lazysource.html).
</summary>
</member>
<member name="T:FSharp.DataFrame.DelayedSeries">
<summary>
 This type exposes a single static method `DelayedSeries.Create` that can be used for
 constructing data series (of type `Series&lt;K, V&gt;`) with lazily loaded data. You can
 use this functionality to create series that represents e.g. an entire price history
 in a database, but only loads data that are actually needed. For more information
 see the [lazy data loading tutorial](../lazysource.html).
 
 ### Example
 
 Assuming we have a function `generate lo hi` that generates data in the specified
 `DateTime` range, we can create lazy series as follows:

     let ls = DelayedSeries.Create(min, max, fun (lo, lob) (hi, hib) -&gt; 
       async { 
         printfn &quot;Query: %A - %A&quot; (lo, lob) (hi, hib)
         return generate lo hi })

 The arguments `min` and `max` specfify the complete range of the series. The 
 function passed to `Create` is called with minimal and maximal required key
 (`lo` and `hi`) and with two values that specify boundary behaviour.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharp.DataFrame.Direction">
<summary>
 Specifies in which direction should we look when performing operations such as
 `Series.Pairwise`. 

 ## Example

     let abc = 
       [ 1 =&gt; &quot;a&quot;; 2 =&gt; &quot;b&quot;; 3 =&gt; &quot;c&quot; ]
       |&gt; Series.ofObservations

     // Using &apos;Forward&apos; the key of the first element is used
     abc.Pairwise(direction=Direction.Forward)
     [fsi:[ 1 =&gt; (&quot;a&quot;, &quot;b&quot;); 2 =&gt; (&quot;b&quot;, &quot;c&quot;) ]]

     // Using &apos;Backward&apos; the key of the second element is used
     abc.Pairwise(direction=Direction.Backward)
     [fsi:[ 2 =&gt; (&quot;a&quot;, &quot;b&quot;); 3 =&gt; (&quot;b&quot;, &quot;c&quot;) ]]

</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharp.DataFrame.Frame.ReadCsv(System.IO.Stream,System.Boolean,System.Int32,System.String,System.String,System.String)">
<summary>
 Load data frame from a CSV file. The operation automatically reads column names from the 
 CSV file (if they are present) and infers the type of values for each column. Columns
 of primitive types (`int`, `float`, etc.) are converted to the right type. Columns of other
 types (such as dates) are not converted automatically.

 ## Parameters

  * `stream` - Specifies the input stream, opened at the beginning of CSV data
  * `skipTypeInference` - Specifies whether the method should skip inferring types
    of columns automatically (when set to `true` you need to provide explicit `schema`)
  * `inferRows` - If `inferTypes=true`, this parameter specifies the number of
    rows to use for type inference. The default value is 0, meaninig all rows.
  * `schema` - A string that specifies CSV schema. See the documentation for 
    information about the schema format.
  * `separators` - A string that specifies one or more (single character) separators
    that are used to separate columns in the CSV file. Use for example `&quot;;&quot;` to 
    parse semicolon separated files.
  * `culture` - Specifies the name of the culture that is used when parsing 
    values in the CSV file (such as `&quot;en-US&quot;`). The default is invariant culture. 
</summary>
</member>
<member name="M:FSharp.DataFrame.Frame.ReadCsv(System.String,System.Boolean,System.Int32,System.String,System.String,System.String)">
<summary>
 Load data frame from a CSV file. The operation automatically reads column names from the 
 CSV file (if they are present) and infers the type of values for each column. Columns
 of primitive types (`int`, `float`, etc.) are converted to the right type. Columns of other
 types (such as dates) are not converted automatically.

 ## Parameters

  * `location` - Specifies a file name or an web location of the resource.
  * `skipTypeInference` - Specifies whether the method should skip inferring types
    of columns automatically (when set to `true` you need to provide explicit `schema`)
  * `inferRows` - If `inferTypes=true`, this parameter specifies the number of
    rows to use for type inference. The default value is 0, meaninig all rows.
  * `schema` - A string that specifies CSV schema. See the documentation for 
    information about the schema format.
  * `separators` - A string that specifies one or more (single character) separators
    that are used to separate columns in the CSV file. Use for example `&quot;;&quot;` to 
    parse semicolon separated files.
  * `culture` - Specifies the name of the culture that is used when parsing 
    values in the CSV file (such as `&quot;en-US&quot;`). The default is invariant culture. 
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharp.DataFrame.Frame.FromRows``2(System.Collections.Generic.IEnumerable{FSharp.DataFrame.Series{``0,``1}})">
<summary>
 Creates a data frame with ordinal Integer index from a sequence of rows.
 The column indices of individual rows are unioned, so if a row has fewer
 columns, it will be successfully added, but there will be missing values.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharp.DataFrame.Frame.FromColumns``3(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{``1,FSharp.DataFrame.Series{``0,``2}}})">
<summary>
 Creates a data frame with ordinal Integer index from a sequence of rows.
 The column indices of individual rows are unioned, so if a row has fewer
 columns, it will be successfully added, but there will be missing values.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharp.DataFrame.FrameExtensions.Where``2(FSharp.DataFrame.Frame{``0,``1},System.Func{System.Collections.Generic.KeyValuePair{``0,FSharp.DataFrame.ObjectSeries{``1}},System.Boolean})">
<summary>
 Filters frame rows using the specified condtion. Returns a new data frame
 that contains rows for which the provided function returned false. The function
 is called with `KeyValuePair` containing the row key as the `Key` and `Value`
 gives access to the row series.

 ## Parameters

  * `frame` - A data frame to invoke the filtering function on.
  * `condition` - A delegate that specifies the filtering condition.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharp.DataFrame.FrameExtensions.GetRows``2(FSharp.DataFrame.Frame{``0,``1},``0[])">
<summary>
 [category:Fancy accessors]
</summary>
</member>
<member name="M:FSharp.DataFrame.FrameExtensions.FillMissing``3(FSharp.DataFrame.Frame{``0,``1},System.Func{FSharp.DataFrame.Series{``0,``2},``0,``2})">
<summary>
 Fill missing values in the frame using the specified function. The specified
 function is called with all series and keys for which the frame does not 
 contain value and the result of the call is used in place of the missing value.

 The operation is only applied to columns (series) that contain values of the
 same type as the return type of the provided filling function. The operation 
 does not attempt to convert between numeric values (so a series containing 
 `float` will not be converted to a series of `int`).

 ## Parameters
  - `frame` - An input data frame that is to be filled
  - `f` - A function that takes a series `Series&lt;R, T&gt;` together with a key `K` 
    in the series and generates a value to be used in a place where the original 
    series contains a missing value.

 [category:Missing values]
</summary>
</member>
<member name="M:FSharp.DataFrame.FrameExtensions.FillMissing``2(FSharp.DataFrame.Frame{``0,``1},FSharp.DataFrame.Direction)">
<summary>
 Fill missing values in the data frame with the nearest available value
 (using the specified direction). Note that the frame may still contain
 missing values after call to this function (e.g. if the first value is not available
 and we attempt to fill series with previous values). This operation can only be
 used on ordered frames.

 ## Parameters
  - `frame` - An input data frame that is to be filled
  - `direction` - Specifies the direction used when searching for 
    the nearest available value. `Backward` means that we want to
    look for the first value with a smaller key while `Forward` searches
    for the nearest greater key.

 [category:Missing values]
</summary>
</member>
<member name="M:FSharp.DataFrame.FrameExtensions.FillMissing``3(FSharp.DataFrame.Frame{``0,``1},``2)">
<summary>
 Fill missing values of a given type in the frame with a constant value.
 The operation is only applied to columns (series) that contain values of the
 same type as the provided filling value. The operation does not attempt to 
 convert between numeric values (so a series containing `float` will not be
 converted to a series of `int`).

 ## Parameters
  - `frame` - An input data frame that is to be filled
  - `value` - A constant value that is used to fill all missing values

 [category:Missing values]
</summary>
</member>
<member name="M:FSharp.DataFrame.FrameExtensions.DropSparseRows``2(FSharp.DataFrame.Frame{``0,``1})">
<summary>
 Creates a new data frame that contains only those rows of the original 
 data frame that are _dense_, meaning that they have a value for each column.
 The resulting data frame has the same number of columns, but may have 
 fewer rows (or no rows at all).
 
 ## Parameters
  - `frame` - An input data frame that is to be filtered

 [category:Missing values]
</summary>
</member>
<member name="M:FSharp.DataFrame.FrameExtensions.DropSparseColumns``2(FSharp.DataFrame.Frame{``0,``1})">
<summary>
 Creates a new data frame that contains only those columns of the original 
 data frame that are _dense_, meaning that they have a value for each row.
 The resulting data frame has the same number of rows, but may have 
 fewer columns (or no columns at all).

 ## Parameters
  - `frame` - An input data frame that is to be filtered

 [category:Missing values]
</summary>
</member>
<member name="">

</member>
<member name="M:FSharp.DataFrame.FrameExtensions.CountRows``2(FSharp.DataFrame.Frame{``0,``1})">
<summary>
 Returns the total number of row keys in the specified frame. This returns
 the total length of the row series, including keys for which there is no 
 value available.
</summary>
</member>
<member name="M:FSharp.DataFrame.FrameExtensions.CountColumns``2(FSharp.DataFrame.Frame{``0,``1})">
<summary>
 Returns the total number of row keys in the specified frame. This returns
 the total length of the row series, including keys for which there is no 
 value available.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharp.DataFrame.FrameUtils.fromRows``3(FSharp.DataFrame.Series{``0,``2})">
<summary>
 Create data frame from a series of rows
</summary>
</member>
<member name="M:FSharp.DataFrame.FrameUtils.fromColumns``3(FSharp.DataFrame.Series{``1,``2})">
<summary>
 Create data frame from a series of columns
</summary>
</member>
<member name="M:FSharp.DataFrame.FrameUtils.createRow``3(``0,FSharp.DataFrame.Series{``1,``2})">
<summary>
 Create data frame containing a single row
</summary>
</member>
<member name="M:FSharp.DataFrame.FrameUtils.createColumn``2(``0,FSharp.DataFrame.ISeries{``1})">
<summary>
 Create data frame containing a single column
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="F:FSharp.DataFrame.FSharp.DataFrame.Frame`2.vectorBuilder">
<summary>
 Vector builder
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:FSharp.DataFrame.Frame`2.Item(`1,FSharp.DataFrame.Series{`0,System.Double})">
<summary>
 [category:Series operations]
</summary>
</member>
<member name="M:FSharp.DataFrame.Frame`2.op_Subtraction(System.Int32,FSharp.DataFrame.Frame{`0,`1})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:FSharp.DataFrame.Frame`2.op_Subtraction(FSharp.DataFrame.Frame{`0,`1},System.Int32)">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:FSharp.DataFrame.Frame`2.op_Subtraction(System.Double,FSharp.DataFrame.Frame{`0,`1})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:FSharp.DataFrame.Frame`2.op_Subtraction(FSharp.DataFrame.Frame{`0,`1},System.Double)">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:FSharp.DataFrame.Frame`2.op_Subtraction(FSharp.DataFrame.Series{`0,System.Int32},FSharp.DataFrame.Frame{`0,`1})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:FSharp.DataFrame.Frame`2.op_Subtraction(FSharp.DataFrame.Frame{`0,`1},FSharp.DataFrame.Series{`0,System.Int32})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:FSharp.DataFrame.Frame`2.op_Subtraction(FSharp.DataFrame.Series{`0,System.Double},FSharp.DataFrame.Frame{`0,`1})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:FSharp.DataFrame.Frame`2.op_Subtraction(FSharp.DataFrame.Frame{`0,`1},FSharp.DataFrame.Series{`0,System.Double})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:FSharp.DataFrame.Frame`2.op_Subtraction(FSharp.DataFrame.Frame{`0,`1},FSharp.DataFrame.Frame{`0,`1})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:FSharp.DataFrame.Frame`2.op_Multiply(System.Int32,FSharp.DataFrame.Frame{`0,`1})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:FSharp.DataFrame.Frame`2.op_Multiply(FSharp.DataFrame.Frame{`0,`1},System.Int32)">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:FSharp.DataFrame.Frame`2.op_Multiply(System.Double,FSharp.DataFrame.Frame{`0,`1})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:FSharp.DataFrame.Frame`2.op_Multiply(FSharp.DataFrame.Frame{`0,`1},System.Double)">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:FSharp.DataFrame.Frame`2.op_Multiply(FSharp.DataFrame.Series{`0,System.Int32},FSharp.DataFrame.Frame{`0,`1})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:FSharp.DataFrame.Frame`2.op_Multiply(FSharp.DataFrame.Frame{`0,`1},FSharp.DataFrame.Series{`0,System.Int32})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:FSharp.DataFrame.Frame`2.op_Multiply(FSharp.DataFrame.Series{`0,System.Double},FSharp.DataFrame.Frame{`0,`1})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:FSharp.DataFrame.Frame`2.op_Multiply(FSharp.DataFrame.Frame{`0,`1},FSharp.DataFrame.Series{`0,System.Double})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:FSharp.DataFrame.Frame`2.op_Multiply(FSharp.DataFrame.Frame{`0,`1},FSharp.DataFrame.Frame{`0,`1})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:FSharp.DataFrame.Frame`2.op_DynamicAssignment``3(FSharp.DataFrame.Frame{``0,``1},``1,System.Collections.Generic.IEnumerable{``2})">
<summary>
 [category:Series operations]
</summary>
</member>
<member name="M:FSharp.DataFrame.Frame`2.op_DynamicAssignment``3(FSharp.DataFrame.Frame{``0,``1},``1,FSharp.DataFrame.Series{``0,``2})">
<summary>
 [category:Series operations]
</summary>
</member>
<member name="M:FSharp.DataFrame.Frame`2.op_Dynamic``2(FSharp.DataFrame.Frame{``0,``1},``1)">
<summary>
 [category:Series operations]
</summary>
</member>
<member name="M:FSharp.DataFrame.Frame`2.op_Division(System.Int32,FSharp.DataFrame.Frame{`0,`1})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:FSharp.DataFrame.Frame`2.op_Division(FSharp.DataFrame.Frame{`0,`1},System.Int32)">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:FSharp.DataFrame.Frame`2.op_Division(System.Double,FSharp.DataFrame.Frame{`0,`1})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:FSharp.DataFrame.Frame`2.op_Division(FSharp.DataFrame.Frame{`0,`1},System.Double)">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:FSharp.DataFrame.Frame`2.op_Division(FSharp.DataFrame.Series{`0,System.Int32},FSharp.DataFrame.Frame{`0,`1})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:FSharp.DataFrame.Frame`2.op_Division(FSharp.DataFrame.Frame{`0,`1},FSharp.DataFrame.Series{`0,System.Int32})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:FSharp.DataFrame.Frame`2.op_Division(FSharp.DataFrame.Series{`0,System.Double},FSharp.DataFrame.Frame{`0,`1})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:FSharp.DataFrame.Frame`2.op_Division(FSharp.DataFrame.Frame{`0,`1},FSharp.DataFrame.Series{`0,System.Double})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:FSharp.DataFrame.Frame`2.op_Division(FSharp.DataFrame.Frame{`0,`1},FSharp.DataFrame.Frame{`0,`1})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:FSharp.DataFrame.Frame`2.op_Addition(System.Int32,FSharp.DataFrame.Frame{`0,`1})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:FSharp.DataFrame.Frame`2.op_Addition(FSharp.DataFrame.Frame{`0,`1},System.Int32)">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:FSharp.DataFrame.Frame`2.op_Addition(System.Double,FSharp.DataFrame.Frame{`0,`1})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:FSharp.DataFrame.Frame`2.op_Addition(FSharp.DataFrame.Frame{`0,`1},System.Double)">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:FSharp.DataFrame.Frame`2.op_Addition(FSharp.DataFrame.Series{`0,System.Int32},FSharp.DataFrame.Frame{`0,`1})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:FSharp.DataFrame.Frame`2.op_Addition(FSharp.DataFrame.Frame{`0,`1},FSharp.DataFrame.Series{`0,System.Int32})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:FSharp.DataFrame.Frame`2.op_Addition(FSharp.DataFrame.Series{`0,System.Double},FSharp.DataFrame.Frame{`0,`1})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:FSharp.DataFrame.Frame`2.op_Addition(FSharp.DataFrame.Frame{`0,`1},FSharp.DataFrame.Series{`0,System.Double})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:FSharp.DataFrame.Frame`2.op_Addition(FSharp.DataFrame.Frame{`0,`1},FSharp.DataFrame.Frame{`0,`1})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="">

</member>
<member name="P:FSharp.DataFrame.Frame`2.RowsDense">
<summary>
 [category:Accessors and slicing]
</summary>
</member>
<member name="P:FSharp.DataFrame.Frame`2.Rows">
<summary>
 [category:Accessors and slicing]
</summary>
</member>
<member name="P:FSharp.DataFrame.Frame`2.RowKeys">
<summary>
 [category:Accessors and slicing]
</summary>
</member>
<member name="">

</member>
<member name="P:FSharp.DataFrame.Frame`2.Item(`1)">
<summary>
 [category:Series operations]
</summary>
</member>
<member name="P:FSharp.DataFrame.Frame`2.Item(`1,`0)">
<summary>
 [category:Accessors and slicing]
</summary>
</member>
<member name="P:FSharp.DataFrame.Frame`2.IsEmpty">
<summary>
 [category:Accessors and slicing]
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:FSharp.DataFrame.Frame`2.ColumnsDense">
<summary>
 [category:Accessors and slicing]
</summary>
</member>
<member name="P:FSharp.DataFrame.Frame`2.Columns">
<summary>
 [category:Accessors and slicing]
</summary>
</member>
<member name="P:FSharp.DataFrame.Frame`2.ColumnKeys">
<summary>
 [category:Accessors and slicing]
</summary>
</member>
<member name="">

</member>
<member name="M:FSharp.DataFrame.Frame`2.TryGetRowAt(System.Int32)">
<summary>
 [category:Accessors and slicing]
</summary>
</member>
<member name="M:FSharp.DataFrame.Frame`2.SeriesApply``1(System.Boolean,System.Func{FSharp.DataFrame.Series{`0,``0},FSharp.DataFrame.ISeries{`0}})">
<summary>
 [category:Series operations]
</summary>
</member>
<member name="M:FSharp.DataFrame.Frame`2.SeriesApply``1(System.Func{FSharp.DataFrame.Series{`0,``0},FSharp.DataFrame.ISeries{`0}})">
<summary>
 [category:Series operations]
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharp.DataFrame.Frame`2.ReplaceSeries``1(`1,System.Collections.Generic.IEnumerable{``0})">
<summary>
 [category:Series operations]
</summary>
</member>
<member name="M:FSharp.DataFrame.Frame`2.ReplaceSeries(`1,FSharp.DataFrame.ISeries{`0})">
<summary>
 [category:Series operations]
</summary>
</member>
<member name="M:FSharp.DataFrame.Frame`2.ReplaceSeries``1(`1,System.Collections.Generic.IEnumerable{``0},FSharp.DataFrame.Lookup)">
<summary>
 [category:Series operations]
</summary>
</member>
<member name="M:FSharp.DataFrame.Frame`2.ReplaceSeries(`1,FSharp.DataFrame.ISeries{`0},FSharp.DataFrame.Lookup)">
<summary>
 [category:Series operations]
</summary>
</member>
<member name="M:FSharp.DataFrame.Frame`2.RealignRows(System.Collections.Generic.IEnumerable{`0})">
<summary>
 [category:Indexing]
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharp.DataFrame.Frame`2.Join(FSharp.DataFrame.Frame{`0,`1},Microsoft.FSharp.Core.FSharpOption{FSharp.DataFrame.JoinKind},Microsoft.FSharp.Core.FSharpOption{FSharp.DataFrame.Lookup})">
<summary>
 [category:Joining]
</summary>
</member>
<member name="M:FSharp.DataFrame.Frame`2.IndexRowsWith``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
 [category:Indexing]
</summary>
</member>
<member name="M:FSharp.DataFrame.Frame`2.GetSeriesAt``1(System.Int32)">
<summary>
 [category:Series operations]
</summary>
</member>
<member name="M:FSharp.DataFrame.Frame`2.GetSeries``1(`1)">
<summary>
 [category:Series operations]
</summary>
</member>
<member name="M:FSharp.DataFrame.Frame`2.GetSeries``1(`1,FSharp.DataFrame.Lookup)">
<summary>
 [category:Series operations]
</summary>
</member>
<member name="M:FSharp.DataFrame.Frame`2.GetRowKeyAt(System.Int32)">
<summary>
 [category:Accessors and slicing]
</summary>
</member>
<member name="M:FSharp.DataFrame.Frame`2.GetRowAt(System.Int32)">
<summary>
 [category:Accessors and slicing]
</summary>
</member>
<member name="M:FSharp.DataFrame.Frame`2.GetRow``1(`0,FSharp.DataFrame.Lookup)">
<summary>
 [category:Fancy accessors]
</summary>
</member>
<member name="M:FSharp.DataFrame.Frame`2.GetRow``1(`0)">
<summary>
 [category:Fancy accessors]
</summary>
</member>
<member name="">

</member>
<member name="M:FSharp.DataFrame.Frame`2.GetColumns``1">
<summary>
 [category:Fancy accessors]
</summary>
</member>
<member name="M:FSharp.DataFrame.Frame`2.GetAllValues``1(System.Boolean)">
<summary>
 [category:Fancy accessors]
</summary>
</member>
<member name="M:FSharp.DataFrame.Frame`2.GetAllValues``1">
<summary>
 [category:Fancy accessors]
</summary>
</member>
<member name="M:FSharp.DataFrame.Frame`2.GetAllSeries``1(System.Boolean)">
<summary>
 [category:Series operations]
</summary>
</member>
<member name="M:FSharp.DataFrame.Frame`2.GetAllSeries``1">
<summary>
 [category:Series operations]
</summary>
</member>
<member name="M:FSharp.DataFrame.Frame`2.FromColumnsNonGeneric(FSharp.DataFrame.Series{`1,FSharp.DataFrame.ISeries{`0}})">
<summary>
 This pretty much duplicates `FrameUtils.ofColumns`, but we need to inline it here,
 otherwise the type inference breaks in very bad ways :-(
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharp.DataFrame.Frame`2.DropSeries(`1)">
<summary>
 [category:Series operations]
</summary>
</member>
<member name="">

</member>
<member name="M:FSharp.DataFrame.Frame`2.Append(FSharp.DataFrame.Frame{`0,`1})">
<summary>
 [category:Joining]
</summary>
</member>
<member name="M:FSharp.DataFrame.Frame`2.AddSeries``1(`1,FSharp.DataFrame.ISeries{`0},FSharp.DataFrame.Lookup)">
<summary>
 [category:Series operations]
</summary>
</member>
<member name="M:FSharp.DataFrame.Frame`2.AddSeries``1(`1,System.Collections.Generic.IEnumerable{``0},FSharp.DataFrame.Lookup)">
<summary>
 [category:Series operations]
</summary>
</member>
<member name="M:FSharp.DataFrame.Frame`2.AddSeries(`1,FSharp.DataFrame.ISeries{`0})">
<summary>
 [category:Series operations]
</summary>
</member>
<member name="M:FSharp.DataFrame.Frame`2.AddSeries``1(`1,System.Collections.Generic.IEnumerable{``0})">
<summary>
 [category:Series operations]
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharp.DataFrame.Frame`2">
<summary>
 A frame contains one Index, with multiple Vecs
 (because this is dynamic, we need to store them as IVec)
</summary>
</member>
<member name="M:FSharp.DataFrame.ICustomLookup`1.Matches(`0)">
<summary>
 Tests whether a specified key matches the current key (for example, in hierarchical indexing
 based on tuples, if the current key represents a pair (1, _) then the value (1, 42) would match).
</summary>
</member>
<member name="T:FSharp.DataFrame.ICustomLookup`1">
<summary>
 Represents a special lookup. This can be used to support hierarchical or duplicate keys
 in an index. A key type `K` can come with associated `ICustomLookup&lt;K&gt;` to provide 
 customized pattern matching (equality testing) 
</summary>
</member>
<member name="P:FSharp.DataFrame.ISeries`1.Vector">
<summary>
 Returns the vector containing data of the series (as an untyped vector)
</summary>
</member>
<member name="P:FSharp.DataFrame.ISeries`1.Index">
<summary>
 Returns the index containing keys of the series 
</summary>
</member>
<member name="M:FSharp.DataFrame.ISeries`1.TryGetObject(`0)">
<summary>
 Attempts to get the value at a specified key and return it as `obj`
</summary>
</member>
<member name="T:FSharp.DataFrame.ISeries`1">
<summary>
 Represents an untyped series with keys of type `K` and values of some unknown type
 (This type should not generally be used directly, but it can be used when you need
 to write code that works on a sequence of series of heterogeneous types).
</summary>
</member>
<member name="P:FSharp.DataFrame.IVector.SuppressPrinting">
<summary>
 When `true`, the formatter in F# Interactive will not attempt to evaluate the
 vector to print it. This is useful when the vector contains lazily loaded data.
</summary>
</member>
<member name="P:FSharp.DataFrame.IVector.ElementType">
<summary>
 Returns the type of elements stored in the current vector as `System.Type`.
 This member is mainly used for internal purposes (to invoke a generic function
 represented by `VectorCallSite1&lt;R&gt;` with the typed version of the current 
 vector as an argument.
</summary>
</member>
<member name="M:FSharp.DataFrame.IVector.GetObject(FSharp.DataFrame.Addressing.Address)">
<summary>
 Return value stored in the vector at a specified address. This is simply an
 untyped version of `GetValue` method on a typed vector.
</summary>
</member>
<member name="T:FSharp.DataFrame.IVector">
<summary>
 Represents an (untyped) vector that stores some values and provides access
 to the values via a generic address. This type should be only used directly when
 extending the DataFrame library and adding a new way of storing or loading data.
 To allow invocation via Reflection, the vector exposes type of elements as `System.Type`.
</summary>
</member>
<member name="P:FSharp.DataFrame.IVector`1.Data">
<summary>
 Returns all data of the vector in one of the supported formats. Depending
 on the vector, data may be returned as a continuous block of memory using
 `IReadOnlyList&lt;T&gt;` or as a lazy sequence `seq&lt;T&gt;`.
</summary>
</member>
<member name="M:FSharp.DataFrame.IVector`1.SelectMissing``1(Microsoft.FSharp.Core.FSharpFunc{FSharp.DataFrame.OptionalValue{`0},FSharp.DataFrame.OptionalValue{``0}})">
<summary>
 Apply the specified function to all values stored in the vector and return
 a new vector (not necessarily of the same representation) with the results.
 The function handles missing values - it is called with optional values and
 may return a missing value as a result of the transformation.
</summary>
</member>
<member name="M:FSharp.DataFrame.IVector`1.Select``1(Microsoft.FSharp.Core.FSharpFunc{`0,``0})">
<summary>
 Apply the specified function to all values stored in the vector and return
 a new vector (not necessarily of the same representation) with the results.
</summary>
</member>
<member name="M:FSharp.DataFrame.IVector`1.GetValue(FSharp.DataFrame.Addressing.Address)">
<summary>
 Returns value stored in the vector at a specified address. 
</summary>
</member>
<member name="T:FSharp.DataFrame.IVector`1">
<summary>
 A generic, typed vector. Represents mapping from addresses to values of type `T`. 
 The vector provides a minimal interface that is required by series and can be
 implemented in a number of ways to provide vector backed by database or an
 alternative representation of data.
</summary>
</member>
<member name="M:FSharp.DataFrame.Index.CreateUnordered``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
 Create an index from a sequence of keys and assume they are not sorted
 (the resulting index is also not sorted).
</summary>
</member>
<member name="M:FSharp.DataFrame.Index.Create``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
 Create an index from a sequence of keys and check if they are sorted or not
</summary>
</member>
<member name="T:FSharp.DataFrame.Index">
<summary>
 Type that provides access to creating indices (represented as `LinearIndex` values)
</summary>
</member>
<member name="F:FSharp.DataFrame.JoinKind.Right">
<summary>
 Take the keys of the right (second) structure and align values from the left (first)
 structure with the keys of the second one. Values for keys not available in the first
 structure will be missing.
</summary>
</member>
<member name="F:FSharp.DataFrame.JoinKind.Left">
<summary>
 Take the keys of the left (first) structure and align values from the right (second)
 structure with the keys of the first one. Values for keys not available in the second
 structure will be missing.
</summary>
</member>
<member name="F:FSharp.DataFrame.JoinKind.Inner">
<summary>
 Take the intersection of the keys available in both structures and align the 
 values of the two structures. The resulting structure cannot contain missing values.
</summary>
</member>
<member name="F:FSharp.DataFrame.JoinKind.Outer">
<summary>
 Combine the keys available in both structures, align the values that
 are available in both of them and mark the remaining values as missing.
</summary>
</member>
<member name="">

</member>
<member name="T:FSharp.DataFrame.JoinKind">
<summary>
 This enumeration specifies joining behavior for `Join` method provided
 by `Series` and `Frame`. Outer join unions the keys (and may introduce
 missing values), inner join takes the intersection of keys; left and
 right joins take the keys of the first or the second series/frame.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="F:FSharp.DataFrame.Lookup.NearestSmaller">
<summary>
 Lookup a value associated with the specified key or with the nearest
 smaller key that has a value available. Fails (or returns missing value)
 only when the specified key is smaller than all available keys.
</summary>
</member>
<member name="F:FSharp.DataFrame.Lookup.NearestGreater">
<summary>
 Lookup a value associated with the specified key or with the nearest
 greater key that has a value available. Fails (or returns missing value)
 only when the specified key is greater than all available keys.
</summary>
</member>
<member name="F:FSharp.DataFrame.Lookup.Exact">
<summary>
 Lookup a value associated with the exact specified key. 
 If the key is not available, then fail or return missing value. 
</summary>
</member>
<member name="">

</member>
<member name="T:FSharp.DataFrame.Lookup">
<summary>
 Represents different behaviors of key lookup in series. For unordered series,
 the only available option is `Lookup.Exact` which finds the exact key - methods
 fail or return missing value if the key is not available in the index. For ordered
 series `Lookup.NearestGreater` finds the first greater key (e.g. later date) with
 a value. `Lookup.NearestSmaller` searches for the first smaller key.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharp.DataFrame.OptionalValueExtensions.OrDefault``1(FSharp.DataFrame.OptionalValue{``0},``0)">
<summary>
 Extension method that returns value in the specified optional value
 or the provided default value (the second argument).
</summary>
</member>
<member name="M:FSharp.DataFrame.OptionalValueExtensions.AsNullable``1(FSharp.DataFrame.OptionalValue{``0})">
<summary>
 Extension method that converts optional value containing a value type
 to a C# friendly `Nullable&lt;T&gt;` or `T?` type.
</summary>
</member>
<member name="T:FSharp.DataFrame.OptionalValueExtensions">
<summary>
 Extension methods for working with optional values from C#. These make
 it easier to provide default values and convert optional values to 
 `Nullable` (when the contained value is value type)
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:FSharp.DataFrame.OptionalValue`1.ValueOrDefault">
<summary>
 Returns the value stored in the current `OptionalValue&lt;T&gt;` or 
 the default value of the type `T` when a value is not present.
</summary>
</member>
<member name="P:FSharp.DataFrame.OptionalValue`1.Value">
<summary>
 Returns the value stored in the current `OptionalValue&lt;T&gt;`. 
 Exceptions:
   `InvalidOperationException` - Thrown when `HasValue` is `false`.
</summary>
</member>
<member name="P:FSharp.DataFrame.OptionalValue`1.Missing">
<summary>
 Returns a new instance of `OptionalValue&lt;T&gt;` that does not contain a value.
</summary>
</member>
<member name="P:FSharp.DataFrame.OptionalValue`1.HasValue">
<summary>
 Gets a value indicating whether the current `OptionalValue&lt;T&gt;` has a value
</summary>
</member>
<member name="M:FSharp.DataFrame.OptionalValue`1.ToString">
<summary>
 Prints the value or &quot;&lt;null&gt;&quot; when the value is present, but is `null`
 or &quot;&lt;missing&gt;&quot; when the value is not present (`HasValue = false`).
</summary>
</member>
<member name="M:FSharp.DataFrame.OptionalValue`1.#ctor(`0)">
<summary>
 Creates a new instance of `OptionalValue&lt;T&gt;` that contains  
 the specified `T` value .
</summary>
</member>
<member name="">

</member>
<member name="T:FSharp.DataFrame.OptionalValue`1">
<summary>
 Value type that represents a potentially missing value. This is similar to 
 `System.Nullable&lt;T&gt;`, but does not restrict the contained value to be a value
 type, so it can be used for storing values of any types. When obtained from
 `DataFrame&lt;R, C&gt;` or `Series&lt;K, T&gt;`, the `Value` will never be `Double.NaN` or `null`
 (but this is not, in general, checked when constructing the value).

 The type is only used in C#-friendly API. F# operations generally use expose
 standard F# `option&lt;T&gt;` type instead. However, there the `OptionalValue` module
 contains helper functions for using this type from F# as well as `Missing` and
 `Present` active patterns.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:FSharp.DataFrame.Series.vectorBuilder">
<summary>
 Vector &amp; index builders
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharp.DataFrame.SeriesExtensions.SampleInto``1(FSharp.DataFrame.Series{System.DateTimeOffset,``0},System.TimeSpan,FSharp.DataFrame.Direction,System.Func{System.DateTimeOffset,Microsoft.FSharp.Core.FSharpFunc{FSharp.DataFrame.Series{System.DateTimeOffset,``0},System.Object}})">
<summary>
 Performs sampling by time and aggregates chunks obtained by time-sampling into a single
 value using a specified function. The operation generates keys starting at the first
 key in the source series, using the specified `interval` and then obtains chunks based on 
 these keys in a fashion similar to the `Series.resample` function.

 ## Parameters
  - `series` - An input series to be resampled
  - `interval` - The interval between the individual samples 
  - `dir` - If this parameter is `Direction.Forward`, then each key is
    used as the smallest key in a chunk; for `Direction.Backward`, the keys are
    used as the greatest keys in a chunk.
  - `aggregate` - A function that is called to aggregate each chunk into a single value.

 ## Remarks
 This operation is only supported on ordered series. The method throws
 `InvalidOperationException` when the series is not ordered. 
 
 [category:Lookup, resampling and scaling]
</summary>
</member>
<member name="M:FSharp.DataFrame.SeriesExtensions.SampleInto``1(FSharp.DataFrame.Series{System.DateTime,``0},System.TimeSpan,FSharp.DataFrame.Direction,System.Func{System.DateTime,Microsoft.FSharp.Core.FSharpFunc{FSharp.DataFrame.Series{System.DateTime,``0},System.Object}})">
<summary>
 Performs sampling by time and aggregates chunks obtained by time-sampling into a single
 value using a specified function. The operation generates keys starting at the first
 key in the source series, using the specified `interval` and then obtains chunks based on 
 these keys in a fashion similar to the `Series.resample` function.

 ## Parameters
  - `series` - An input series to be resampled
  - `interval` - The interval between the individual samples 
  - `dir` - If this parameter is `Direction.Forward`, then each key is
    used as the smallest key in a chunk; for `Direction.Backward`, the keys are
    used as the greatest keys in a chunk.
  - `aggregate` - A function that is called to aggregate each chunk into a single value.

 ## Remarks
 This operation is only supported on ordered series. The method throws
 `InvalidOperationException` when the series is not ordered. 
 
 [category:Lookup, resampling and scaling]
</summary>
</member>
<member name="M:FSharp.DataFrame.SeriesExtensions.Sample``1(FSharp.DataFrame.Series{System.DateTimeOffset,``0},System.TimeSpan)">
<summary>
 Finds values at, or near, the specified times in a given series. The operation generates
 keys starting from the smallest key of the original series, using the specified `interval`
 and then finds nearest smaller values close to such keys. The function generates samples
 at, or just before the end of an interval and at, or after, the end of the series.
 
 ## Parameters
  - `series` - An input series to be resampled
  - `interval` - The interval between the individual samples 
 
 ## Remarks
 This operation is only supported on ordered series. The method throws
 `InvalidOperationException` when the series is not ordered. 
 
 [category:Lookup, resampling and scaling]
</summary>
</member>
<member name="M:FSharp.DataFrame.SeriesExtensions.Sample``1(FSharp.DataFrame.Series{System.DateTime,``0},System.TimeSpan)">
<summary>
 Finds values at, or near, the specified times in a given series. The operation generates
 keys starting from the smallest key of the original series, using the specified `interval`
 and then finds nearest smaller values close to such keys. The function generates samples
 at, or just before the end of an interval and at, or after, the end of the series.
 
 ## Parameters
  - `series` - An input series to be resampled
  - `interval` - The interval between the individual samples 
 
 ## Remarks
 This operation is only supported on ordered series. The method throws
 `InvalidOperationException` when the series is not ordered. 
 
 [category:Lookup, resampling and scaling]
</summary>
</member>
<member name="M:FSharp.DataFrame.SeriesExtensions.Sample``1(FSharp.DataFrame.Series{System.DateTimeOffset,``0},System.TimeSpan,FSharp.DataFrame.Direction)">
<summary>
 Finds values at, or near, the specified times in a given series. The operation generates
 keys starting from the smallest key of the original series, using the specified `interval`
 and then finds nearest smaller values close to such keys according to `dir`.
 
 ## Parameters
  - `series` - An input series to be resampled
  - `interval` - The interval between the individual samples 
  - `dir` - Specifies how the keys should be generated. `Direction.Forward` means that the 
    key is the smallest value of each chunk (and so first key of the series is returned and 
    the last is not, unless it matches exactly _start + k*interval_); `Direction.Backward`
    means that the first key is skipped and sample is generated at, or just before the end 
    of interval and at the end of the series.
 
 ## Remarks
 This operation is only supported on ordered series. The method throws
 `InvalidOperationException` when the series is not ordered. 
 
 [category:Lookup, resampling and scaling]
</summary>
</member>
<member name="M:FSharp.DataFrame.SeriesExtensions.Sample``1(FSharp.DataFrame.Series{System.DateTime,``0},System.TimeSpan,FSharp.DataFrame.Direction)">
<summary>
 Finds values at, or near, the specified times in a given series. The operation generates
 keys starting from the smallest key of the original series, using the specified `interval`
 and then finds nearest smaller values close to such keys according to `dir`.
 
 ## Parameters
  - `series` - An input series to be resampled
  - `interval` - The interval between the individual samples 
  - `lookup` - Specifies how the lookup based on keys is performed. `Exact` means that the
    values at exact keys will be returned; `NearestGreater` returns the nearest greater key value
    (starting at the first key) and `NearestSmaller` returns the nearest smaller key value
    (starting at most `interval` after the end of the series)
 
 ## Remarks
 This operation is only supported on ordered series. The method throws
 `InvalidOperationException` when the series is not ordered. 
 
 [category:Lookup, resampling and scaling]
</summary>
</member>
<member name="M:FSharp.DataFrame.SeriesExtensions.Sample``1(FSharp.DataFrame.Series{System.DateTimeOffset,``0},System.DateTimeOffset,System.TimeSpan,FSharp.DataFrame.Direction)">
<summary>
 Finds values at, or near, the specified times in a given series. The operation generates
 keys starting at the specified `start` time, using the specified `interval`
 and then finds nearest smaller values close to such keys according to `dir`.
 
 ## Parameters
  - `series` - An input series to be resampled
  - `start` - The initial time to be used for sampling
  - `interval` - The interval between the individual samples 
  - `lookup` - Specifies how the lookup based on keys is performed. `Exact` means that the
    values at exact keys will be returned; `NearestGreater` returns the nearest greater key value
    (starting at the first key) and `NearestSmaller` returns the nearest smaller key value
    (starting at most `interval` after the end of the series)
 
 ## Remarks
 This operation is only supported on ordered series. The method throws
 `InvalidOperationException` when the series is not ordered. 
 
 [category:Lookup, resampling and scaling]
</summary>
</member>
<member name="M:FSharp.DataFrame.SeriesExtensions.Sample``1(FSharp.DataFrame.Series{System.DateTime,``0},System.DateTime,System.TimeSpan,FSharp.DataFrame.Direction)">
<summary>
 Finds values at, or near, the specified times in a given series. The operation generates
 keys starting at the specified `start` time, using the specified `interval`
 and then finds nearest smaller values close to such keys according to `dir`.
 
 ## Parameters
  - `series` - An input series to be resampled
  - `start` - The initial time to be used for sampling
  - `interval` - The interval between the individual samples 
  - `lookup` - Specifies how the lookup based on keys is performed. `Exact` means that the
    values at exact keys will be returned; `NearestGreater` returns the nearest greater key value
    (starting at the first key) and `NearestSmaller` returns the nearest smaller key value
    (starting at most `interval` after the end of the series)
 
 ## Remarks
 This operation is only supported on ordered series. The method throws
 `InvalidOperationException` when the series is not ordered. 
 
 [category:Lookup, resampling and scaling]
</summary>
</member>
<member name="M:FSharp.DataFrame.SeriesExtensions.ResampleUniform``4(FSharp.DataFrame.Series{``0,``1},System.Func{``0,``2},System.Func{``2,``2},FSharp.DataFrame.Lookup,Microsoft.FSharp.Core.FSharpFunc{FSharp.DataFrame.Series{``0,``1},``3})">
<summary>
 Resample the series based on equivalence class on the keys and also generate values 
 for all keys of the target space that are between the minimal and maximal key of the
 specified series (e.g. generate value for all days in the range covered by the series).
 A specified function `keyProj` is used to project keys to another space and `nextKey`
 is used to generate all keys in the range. The chunk is then aggregated using `aggregate`.

 When there are no values for a (generated) key, then the function attempts to get the
 greatest value from the previous smaller chunk (i.e. value for the previous date time).

 ## Parameters
  - `series` - An input series to be resampled
  - `fillMode` - When set to `Lookup.NearestSmaller` or `Lookup.NearestGreater`, 
     the function searches for a nearest available observation in an neighboring chunk.
     Otherwise, the function `f` is called with an empty series as an argument.
  - `keyProj` - A function that transforms keys from original space to a new 
    space (which is then used for grouping based on equivalence)
  - `nextKey` - A function that gets the next key in the transformed space
  - `aggregate` - A function that is used to collapse a generated chunk into a 
    single value. The function may be called on empty series when `fillMode` is
    `Lookup.Exact`.
    
 ## Remarks
 This operation is only supported on ordered series. The method throws
 `InvalidOperationException` when the series is not ordered. 
 
 [category:Lookup, resampling and scaling]
</summary>
</member>
<member name="M:FSharp.DataFrame.SeriesExtensions.ResampleUniform``3(FSharp.DataFrame.Series{``0,``1},System.Func{``0,``2},System.Func{``2,``2})">
<summary>
 Resample the series based on equivalence class on the keys and also generate values 
 for all keys of the target space that are between the minimal and maximal key of the
 specified series (e.g. generate value for all days in the range covered by the series).
 For each equivalence class (e.g. date), select the latest value (with greatest key).
 A specified function `keyProj` is used to project keys to another space and `nextKey`
 is used to generate all keys in the range. 

 When there are no values for a (generated) key, then the function attempts to get the
 greatest value from the previous smaller chunk (i.e. value for the previous date time).

 ## Parameters
  - `series` - An input series to be resampled
  - `fillMode` - When set to `Lookup.NearestSmaller` or `Lookup.NearestGreater`, 
     the function searches for a nearest available observation in an neighboring chunk.
     Otherwise, the function `f` is called with an empty series as an argument.
  - `keyProj` - A function that transforms keys from original space to a new 
    space (which is then used for grouping based on equivalence)
  - `nextKey` - A function that gets the next key in the transformed space
    
 ## Remarks
 This operation is only supported on ordered series. The method throws
 `InvalidOperationException` when the series is not ordered. 
 
 [category:Lookup, resampling and scaling]
</summary>
</member>
<member name="M:FSharp.DataFrame.SeriesExtensions.ResampleEquivalence``4(FSharp.DataFrame.Series{``0,``1},System.Func{``0,``2},System.Func{FSharp.DataFrame.Series{``0,``1},``3})">
<summary>
 Resample the series based on equivalence class on the keys. A specified function
 `keyProj` is used to project keys to another space and the observations for which the 
 projected keys are equivalent are grouped into chunks. The chunks are then transformed
 to values using the provided function `f`.

 ## Parameters
  - `series` - An input series to be resampled
  - `keyProj` - A function that transforms keys from original space to a new 
    space (which is then used for grouping based on equivalence)
  - `aggregate` - A function that is used to collapse a generated chunk into a 
    single value. 

 ## Remarks
 This operation is only supported on ordered series. The method throws
 `InvalidOperationException` when the series is not ordered. For unordered
 series, similar functionality can be implemented using `GroupBy`.
 
 [category:Lookup, resampling and scaling]
</summary>
</member>
<member name="M:FSharp.DataFrame.SeriesExtensions.ResampleEquivalence``3(FSharp.DataFrame.Series{``0,``1},System.Func{``0,``2})">
<summary>
 Resample the series based on equivalence class on the keys. A specified function
 `keyProj` is used to project keys to another space and the observations for which the 
 projected keys are equivalent are grouped into chunks. The chunks are then returned
 as nested series.

 ## Parameters
  - `series` - An input series to be resampled
  - `keyProj` - A function that transforms keys from original space to a new 
    space (which is then used for grouping based on equivalence)

 ## Remarks
 This operation is only supported on ordered series. The method throws
 `InvalidOperationException` when the series is not ordered. For unordered
 series, similar functionality can be implemented using `GroupBy`.
 
 [category:Lookup, resampling and scaling]
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharp.DataFrame.SeriesExtensions.GetObservations``2(FSharp.DataFrame.Series{``0,``1})">
<summary>
 Return observations with available values. The operation skips over 
 all keys with missing values (such as values created from `null`,
 `Double.NaN`, or those that are missing due to outer join etc.).
</summary>
</member>
<member name="M:FSharp.DataFrame.SeriesExtensions.GetAllObservations``2(FSharp.DataFrame.Series{``0,``1})">
<summary>
 Returns all keys from the sequence, together with the associated (optional)
 values. The values are returned using the `OptionalValue&lt;T&gt;` struct which
 provides `HasValue` for testing if the value is available.
</summary>
</member>
<member name="">

</member>
<member name="M:FSharp.DataFrame.SeriesExtensions.FillMissing``2(FSharp.DataFrame.Series{``0,``1},System.Func{``0,``1})">
<summary>
 Fill missing values in the series using the specified function.
 The specified function is called with all keys for which the series
 does not contain value and the result of the call is used in place 
 of the missing value. 

 ## Parameters
  - `series` - An input series that is to be filled
  - `filler` - A function that takes key `K` and generates a value to be
    used in a place where the original series contains a missing value.

 ## Remarks
 This function can be used to implement more complex interpolation.
 For example see [handling missing values in the tutorial](../features.html#missing)

 [category:Missing values]
</summary>
</member>
<member name="M:FSharp.DataFrame.SeriesExtensions.FillMissing``2(FSharp.DataFrame.Series{``0,``1},FSharp.DataFrame.Direction)">
<summary>
 Fill missing values in the series with the nearest available value
 (using the specified direction). The default direction is `Direction.Backward`.
 Note that the series may still contain missing values after call to this 
 function. This operation can only be used on ordered series. 

 ## Example

     let sample = Series.ofValues [ Double.NaN; 1.0; Double.NaN; 3.0 ]

     // Returns a series consisting of [1; 1; 3; 3]
     sample.FillMissing(Direction.Backward)

     // Returns a series consisting of [&lt;missing&gt;; 1; 1; 3]
     sample.FillMissing(Direction.Forward)

 ## Parameters
  - `direction` - Specifies the direction used when searching for 
    the nearest available value. `Backward` means that we want to
    look for the first value with a smaller key while `Forward` searches
    for the nearest greater key.

 [category:Missing values]
</summary>
</member>
<member name="M:FSharp.DataFrame.SeriesExtensions.FillMissing``2(FSharp.DataFrame.Series{``0,``1},``1)">
<summary>
 Fill missing values in the series with a constant value.

 ## Parameters
  - `series` - An input series that is to be filled
  - `value` - A constant value that is used to fill all missing values

 [category:Missing values]
</summary>
</member>
<member name="">

</member>
<member name="M:FSharp.DataFrame.SeriesExtensions.DropMissing``2(FSharp.DataFrame.Series{``0,``1})">
<summary>
 Drop missing values from the specified series. The returned series contains 
 only those keys for which there is a value available in the original one.

 ## Parameters
  - `series` - An input series to be filtered

 ## Example

     let s = series [ 1 =&gt; 1.0; 2 =&gt; Double.NaN ]
     s.DropMissing()
     [fsi:val it : Series&lt;int,float&gt; = series [ 1 =&gt; 1]

 [category:Missing values]
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharp.DataFrame.SeriesExtensions.CountValues``2(FSharp.DataFrame.Series{``0,``1})">
<summary>
 Returns the total number of values in the specified series. This excludes
 missing values or not available values (such as values created from `null`,
 `Double.NaN`, or those that are missing due to outer join etc.).
</summary>
</member>
<member name="M:FSharp.DataFrame.SeriesExtensions.CountKeys``2(FSharp.DataFrame.Series{``0,``1})">
<summary>
 Returns the total number of keys in the specified series. This returns
 the total length of the series, including keys for which there is no 
 value available.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharp.DataFrame.Series`2.op_Subtraction(FSharp.DataFrame.Series{`0,System.Double},FSharp.DataFrame.Series{`0,System.Double})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:FSharp.DataFrame.Series`2.op_Subtraction(FSharp.DataFrame.Series{`0,System.Int32},FSharp.DataFrame.Series{`0,System.Int32})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:FSharp.DataFrame.Series`2.op_Subtraction(FSharp.DataFrame.Series{`0,System.Double},System.Double)">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:FSharp.DataFrame.Series`2.op_Subtraction(System.Double,FSharp.DataFrame.Series{`0,System.Double})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:FSharp.DataFrame.Series`2.op_Subtraction(FSharp.DataFrame.Series{`0,System.Int32},System.Int32)">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:FSharp.DataFrame.Series`2.op_Subtraction(System.Int32,FSharp.DataFrame.Series{`0,System.Int32})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:FSharp.DataFrame.Series`2.op_Multiply(FSharp.DataFrame.Series{`0,System.Double},FSharp.DataFrame.Series{`0,System.Double})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:FSharp.DataFrame.Series`2.op_Multiply(FSharp.DataFrame.Series{`0,System.Int32},FSharp.DataFrame.Series{`0,System.Int32})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:FSharp.DataFrame.Series`2.op_Multiply(FSharp.DataFrame.Series{`0,System.Double},System.Double)">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:FSharp.DataFrame.Series`2.op_Multiply(System.Double,FSharp.DataFrame.Series{`0,System.Double})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:FSharp.DataFrame.Series`2.op_Multiply(FSharp.DataFrame.Series{`0,System.Int32},System.Int32)">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:FSharp.DataFrame.Series`2.op_Multiply(System.Int32,FSharp.DataFrame.Series{`0,System.Int32})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:FSharp.DataFrame.Series`2.op_Dynamic``1(FSharp.DataFrame.Series{System.String,``0},System.String)">
<summary>
 [category:Accessors and slicing]
</summary>
</member>
<member name="M:FSharp.DataFrame.Series`2.op_Division(FSharp.DataFrame.Series{`0,System.Double},FSharp.DataFrame.Series{`0,System.Double})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:FSharp.DataFrame.Series`2.op_Division(FSharp.DataFrame.Series{`0,System.Int32},FSharp.DataFrame.Series{`0,System.Int32})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:FSharp.DataFrame.Series`2.op_Division(FSharp.DataFrame.Series{`0,System.Double},System.Double)">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:FSharp.DataFrame.Series`2.op_Division(System.Double,FSharp.DataFrame.Series{`0,System.Double})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:FSharp.DataFrame.Series`2.op_Division(FSharp.DataFrame.Series{`0,System.Int32},System.Int32)">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:FSharp.DataFrame.Series`2.op_Division(System.Int32,FSharp.DataFrame.Series{`0,System.Int32})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:FSharp.DataFrame.Series`2.op_Addition(FSharp.DataFrame.Series{`0,System.Double},FSharp.DataFrame.Series{`0,System.Double})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:FSharp.DataFrame.Series`2.op_Addition(FSharp.DataFrame.Series{`0,System.Int32},FSharp.DataFrame.Series{`0,System.Int32})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:FSharp.DataFrame.Series`2.op_Addition(FSharp.DataFrame.Series{`0,System.Double},System.Double)">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:FSharp.DataFrame.Series`2.op_Addition(System.Double,FSharp.DataFrame.Series{`0,System.Double})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:FSharp.DataFrame.Series`2.op_Addition(FSharp.DataFrame.Series{`0,System.Int32},System.Int32)">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:FSharp.DataFrame.Series`2.op_Addition(System.Int32,FSharp.DataFrame.Series{`0,System.Int32})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:FSharp.DataFrame.Series`2.Vector">
<summary>
 Returns the vector associated with this series. This member should not generally
 be accessed directly, because all functionality is exposed through series operations.

 [category:Series data]
</summary>
</member>
<member name="P:FSharp.DataFrame.Series`2.Values">
<summary>
 Returns a collection of values that are available in the series data.
 Note that the length of this sequence does not match the `Keys` sequence
 if there are missing values. To get matching sequence, use the `Observations`
 property or `Series.observation`.

 [category:Series data]
</summary>
</member>
<member name="P:FSharp.DataFrame.Series`2.Observations">
<summary>
 Returns a collection of observations that form this series. Note that this property
 skips over all missing (or NaN) values. Observations are returned as `KeyValuePair&lt;K, V&gt;` 
 objects. For an F# alternative that uses tuples, see `Series.observations`.

 [category:Series data]
</summary>
</member>
<member name="P:FSharp.DataFrame.Series`2.Keys">
<summary>
 Returns a collection of keys that are defined by the index of this series.
 Note that the length of this sequence does not match the `Values` sequence
 if there are missing values. To get matching sequence, use the `Observations`
 property or `Series.observation`.

 [category:Series data]
</summary>
</member>
<member name="P:FSharp.DataFrame.Series`2.KeyRange">
<summary>
 [category:Series data]
</summary>
</member>
<member name="P:FSharp.DataFrame.Series`2.Item(FSharp.DataFrame.ICustomLookup{`0})">
<summary>
 [category:Accessors and slicing]
</summary>
</member>
<member name="P:FSharp.DataFrame.Series`2.Item(System.Collections.Generic.IEnumerable{`0})">
<summary>
 [category:Accessors and slicing]
</summary>
</member>
<member name="P:FSharp.DataFrame.Series`2.Item(`0)">
<summary>
 [category:Accessors and slicing]
</summary>
</member>
<member name="P:FSharp.DataFrame.Series`2.IsEmpty">
<summary>
 [category:Series data]
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:FSharp.DataFrame.Series`2.Index">
<summary>
 Returns the index associated with this series. This member should not generally
 be accessed directly, because all functionality is exposed through series operations.

 [category:Series data]
</summary>
</member>
<member name="M:FSharp.DataFrame.Series`2.WhereOptional(System.Func{System.Collections.Generic.KeyValuePair{`0,FSharp.DataFrame.OptionalValue{`1}},System.Boolean})">
<summary>
 [category:Projection and filtering]
</summary>
</member>
<member name="M:FSharp.DataFrame.Series`2.Where(System.Func{System.Collections.Generic.KeyValuePair{`0,`1},System.Boolean})">
<summary>
 [category:Projection and filtering]
</summary>
</member>
<member name="">

</member>
<member name="M:FSharp.DataFrame.Series`2.Union(FSharp.DataFrame.Series{`0,`1},FSharp.DataFrame.UnionBehavior)">
<summary>
 [category:Appending and joining]
</summary>
</member>
<member name="M:FSharp.DataFrame.Series`2.Union(FSharp.DataFrame.Series{`0,`1})">
<summary>
 [category:Appending and joining]
</summary>
</member>
<member name="M:FSharp.DataFrame.Series`2.TryGetObservation(`0)">
<summary>
 Attempts to get a value at the specified &apos;key&apos;

 [category:Accessors and slicing]
</summary>
</member>
<member name="M:FSharp.DataFrame.Series`2.TryGetObservation(`0,FSharp.DataFrame.Lookup)">
<summary>
 [category:Accessors and slicing]
</summary>
</member>
<member name="">

</member>
<member name="M:FSharp.DataFrame.Series`2.TryGetAt(System.Int32)">
<summary>
 [category:Accessors and slicing]
</summary>
</member>
<member name="M:FSharp.DataFrame.Series`2.TryGet(`0)">
<summary>
 [category:Accessors and slicing]
</summary>
</member>
<member name="M:FSharp.DataFrame.Series`2.TryGet(`0,FSharp.DataFrame.Lookup)">
<summary>
 [category:Accessors and slicing]
</summary>
</member>
<member name="M:FSharp.DataFrame.Series`2.Truncate(FSharp.DataFrame.Series{`0,System.Double})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="">

</member>
<member name="M:FSharp.DataFrame.Series`2.Tanh(FSharp.DataFrame.Series{`0,System.Double})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:FSharp.DataFrame.Series`2.Tan(FSharp.DataFrame.Series{`0,System.Double})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:FSharp.DataFrame.Series`2.Sqrt(FSharp.DataFrame.Series{`0,System.Double})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:FSharp.DataFrame.Series`2.Sinh(FSharp.DataFrame.Series{`0,System.Double})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:FSharp.DataFrame.Series`2.Sin(FSharp.DataFrame.Series{`0,System.Double})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:FSharp.DataFrame.Series`2.Sign(FSharp.DataFrame.Series{`0,System.Double})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:FSharp.DataFrame.Series`2.SelectOptional``1(System.Func{System.Collections.Generic.KeyValuePair{`0,FSharp.DataFrame.OptionalValue{`1}},FSharp.DataFrame.OptionalValue{``0}})">
<summary>
 [category:Projection and filtering]
</summary>
</member>
<member name="M:FSharp.DataFrame.Series`2.SelectKeys``1(System.Func{System.Collections.Generic.KeyValuePair{`0,FSharp.DataFrame.OptionalValue{`1}},``0})">
<summary>
 [category:Projection and filtering]
</summary>
</member>
<member name="M:FSharp.DataFrame.Series`2.Select``1(System.Func{System.Collections.Generic.KeyValuePair{`0,`1},``0})">
<summary>
 [category:Projection and filtering]
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharp.DataFrame.Series`2.Round(FSharp.DataFrame.Series{`0,System.Double})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:FSharp.DataFrame.Series`2.Resample(System.Collections.Generic.IEnumerable{`0},FSharp.DataFrame.Direction)">
<summary>
 Resample the series based on a provided collection of keys. The values of the series
 are aggregated into chunks based on the specified keys. Depending on `direction`, the 
 specified key is either used as the smallest or as the greatest key of the chunk (with
 the exception of boundaries that are added to the first/last chunk). The chunks
 are then returned as a nested series. 

 ## Parameters
  - `keys` - A collection of keys to be used for resampling of the series
  - `direction` - If this parameter is `Direction.Forward`, then each key is
    used as the smallest key in a chunk; for `Direction.Backward`, the keys are
    used as the greatest keys in a chunk.

 ## Remarks
 This operation is only supported on ordered series. The method throws
 `InvalidOperationException` when the series is not ordered.

 [category:Resampling]
</summary>
</member>
<member name="M:FSharp.DataFrame.Series`2.Resample``1(System.Collections.Generic.IEnumerable{`0},FSharp.DataFrame.Direction,System.Func{`0,FSharp.DataFrame.Series{`0,`1},``0})">
<summary>
 Resample the series based on a provided collection of keys. The values of the series
 are aggregated into chunks based on the specified keys. Depending on `direction`, the 
 specified key is either used as the smallest or as the greatest key of the chunk (with
 the exception of boundaries that are added to the first/last chunk).

 Such chunks are then aggregated using the provided `valueSelector` and `keySelector`
 (an overload that does not take `keySelector` just selects the explicitly provided key).

 ## Parameters
  - `keys` - A collection of keys to be used for resampling of the series
  - `direction` - If this parameter is `Direction.Forward`, then each key is
    used as the smallest key in a chunk; for `Direction.Backward`, the keys are
    used as the greatest keys in a chunk.
  - `valueSelector` - A function that is used to collapse a generated chunk into a 
    single value. Note that this function may be called with empty series.

 ## Remarks
 This operation is only supported on ordered series. The method throws
 `InvalidOperationException` when the series is not ordered.

 [category:Resampling]
</summary>
</member>
<member name="M:FSharp.DataFrame.Series`2.Resample``2(System.Collections.Generic.IEnumerable{`0},FSharp.DataFrame.Direction,System.Func{``0,FSharp.DataFrame.Series{`0,`1},``1},System.Func{`0,FSharp.DataFrame.Series{`0,`1},``0})">
<summary>
 Resample the series based on a provided collection of keys. The values of the series
 are aggregated into chunks based on the specified keys. Depending on `direction`, the 
 specified key is either used as the smallest or as the greatest key of the chunk (with
 the exception of boundaries that are added to the first/last chunk).

 Such chunks are then aggregated using the provided `valueSelector` and `keySelector`
 (an overload that does not take `keySelector` just selects the explicitly provided key).

 ## Parameters
  - `keys` - A collection of keys to be used for resampling of the series
  - `direction` - If this parameter is `Direction.Forward`, then each key is
    used as the smallest key in a chunk; for `Direction.Backward`, the keys are
    used as the greatest keys in a chunk.
  - `valueSelector` - A function that is used to collapse a generated chunk into a 
    single value. Note that this function may be called with empty series.
  - `keySelector` - A function that is used to generate a new key for each chunk.

 ## Remarks
 This operation is only supported on ordered series. The method throws
 `InvalidOperationException` when the series is not ordered.

 [category:Resampling]
</summary>
</member>
<member name="M:FSharp.DataFrame.Series`2.Realign(System.Collections.Generic.IEnumerable{`0})">
<summary>
 [category:Indexing]
</summary>
</member>
<member name="M:FSharp.DataFrame.Series`2.Pow(FSharp.DataFrame.Series{`0,System.Double},FSharp.DataFrame.Series{`0,System.Double})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:FSharp.DataFrame.Series`2.Pow(FSharp.DataFrame.Series{`0,System.Double},System.Double)">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:FSharp.DataFrame.Series`2.Pow(System.Double,FSharp.DataFrame.Series{`0,System.Double})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:FSharp.DataFrame.Series`2.Pairwise(Microsoft.FSharp.Core.FSharpOption{FSharp.DataFrame.Boundary},Microsoft.FSharp.Core.FSharpOption{FSharp.DataFrame.Direction})">
<summary>
 [category:Aggregation]
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharp.DataFrame.Series`2.Log10(FSharp.DataFrame.Series{`0,System.Double})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:FSharp.DataFrame.Series`2.Log(FSharp.DataFrame.Series{`0,System.Double})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:FSharp.DataFrame.Series`2.JoinInner``1(FSharp.DataFrame.Series{`0,``0})">
<summary>
 [category:Appending and joining]
</summary>
</member>
<member name="M:FSharp.DataFrame.Series`2.Join``1(FSharp.DataFrame.Series{`0,``0},FSharp.DataFrame.JoinKind,FSharp.DataFrame.Lookup)">
<summary>
 [category:Appending and joining]
</summary>
</member>
<member name="M:FSharp.DataFrame.Series`2.Join``1(FSharp.DataFrame.Series{`0,``0},FSharp.DataFrame.JoinKind)">
<summary>
 [category:Appending and joining]
</summary>
</member>
<member name="M:FSharp.DataFrame.Series`2.Join``1(FSharp.DataFrame.Series{`0,``0})">
<summary>
 [category:Appending and joining]
</summary>
</member>
<member name="M:FSharp.DataFrame.Series`2.IndexWith``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
 [category:Indexing]
</summary>
</member>
<member name="M:FSharp.DataFrame.Series`2.IndexOrdinally">
<summary>
 [category:Indexing]
</summary>
</member>
<member name="M:FSharp.DataFrame.Series`2.GroupBy``2(Microsoft.FSharp.Core.FSharpFunc{`0,Microsoft.FSharp.Core.FSharpFunc{`1,``0}},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{FSharp.DataFrame.Series{`0,`1},FSharp.DataFrame.OptionalValue{``1}}})">
<summary>
 [category:Aggregation]
</summary>
</member>
<member name="M:FSharp.DataFrame.Series`2.GetSubrange(Microsoft.FSharp.Core.FSharpOption{System.Tuple{`0,FSharp.DataFrame.Indices.BoundaryBehavior}},Microsoft.FSharp.Core.FSharpOption{System.Tuple{`0,FSharp.DataFrame.Indices.BoundaryBehavior}})">
<summary>
 [category:Accessors and slicing]
</summary>
</member>
<member name="M:FSharp.DataFrame.Series`2.GetSlice(Microsoft.FSharp.Core.FSharpOption{`0},Microsoft.FSharp.Core.FSharpOption{`0})">
<summary>
 [category:Accessors and slicing]
</summary>
</member>
<member name="M:FSharp.DataFrame.Series`2.GetObservation(`0)">
<summary>
 [category:Accessors and slicing]
</summary>
</member>
<member name="M:FSharp.DataFrame.Series`2.GetObservation(`0,FSharp.DataFrame.Lookup)">
<summary>
 [category:Accessors and slicing]
</summary>
</member>
<member name="M:FSharp.DataFrame.Series`2.GetKeyAt(System.Int32)">
<summary>
 [category:Accessors and slicing]
</summary>
</member>
<member name="M:FSharp.DataFrame.Series`2.GetItems(System.Collections.Generic.IEnumerable{`0},FSharp.DataFrame.Lookup)">
<summary>
 Returns a new series with an index containing the specified keys.
 When the key is not found in the current series, the newly returned
 series will contain a missing value. When the second parameter is not
 specified, the keys have to exactly match the keys in the current series
 (`Lookup.Exact`).

 ## Parameters

  * `keys` - A collection of keys in the current series.
  * `lookup` - Specifies the lookup behavior when searching for keys in 
    the current series. `Lookup.NearestGreater` and `Lookup.NearestSmaller`
    can be used when the current series is ordered.

 [category:Accessors and slicing]
</summary>
</member>
<member name="M:FSharp.DataFrame.Series`2.GetItems(System.Collections.Generic.IEnumerable{`0})">
<summary>
 Returns a new series with an index containing the specified keys.
 When the key is not found in the current series, the newly returned
 series will contain a missing value. When the second parameter is not
 specified, the keys have to exactly match the keys in the current series
 (`Lookup.Exact`).

 ## Parameters

  * `keys` - A collection of keys in the current series.

 [category:Accessors and slicing]
</summary>
</member>
<member name="">

</member>
<member name="M:FSharp.DataFrame.Series`2.GetByLevel(FSharp.DataFrame.ICustomLookup{`0})">
<summary>
 [category:Accessors and slicing]
</summary>
</member>
<member name="M:FSharp.DataFrame.Series`2.GetAt(System.Int32)">
<summary>
 [category:Accessors and slicing]
</summary>
</member>
<member name="M:FSharp.DataFrame.Series`2.Get(`0)">
<summary>
 [category:Accessors and slicing]
</summary>
</member>
<member name="M:FSharp.DataFrame.Series`2.Get(`0,FSharp.DataFrame.Lookup)">
<summary>
 [category:Accessors and slicing]
</summary>
</member>
<member name="">

</member>
<member name="M:FSharp.DataFrame.Series`2.Floor(FSharp.DataFrame.Series{`0,System.Double})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:FSharp.DataFrame.Series`2.Exp(FSharp.DataFrame.Series{`0,System.Double})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="">

</member>
<member name="M:FSharp.DataFrame.Series`2.Cosh(FSharp.DataFrame.Series{`0,System.Double})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:FSharp.DataFrame.Series`2.Cos(FSharp.DataFrame.Series{`0,System.Double})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:FSharp.DataFrame.Series`2.Ceiling(FSharp.DataFrame.Series{`0,System.Double})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:FSharp.DataFrame.Series`2.Atan(FSharp.DataFrame.Series{`0,System.Double})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:FSharp.DataFrame.Series`2.Asin(FSharp.DataFrame.Series{`0,System.Double})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:FSharp.DataFrame.Series`2.Append(FSharp.DataFrame.Series{`0,`1})">
<summary>
 [category:Appending and joining]
</summary>
</member>
<member name="">

</member>
<member name="M:FSharp.DataFrame.Series`2.Acos(FSharp.DataFrame.Series{`0,System.Double})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:FSharp.DataFrame.Series`2.Abs(FSharp.DataFrame.Series{`0,System.Int32})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="M:FSharp.DataFrame.Series`2.Abs(FSharp.DataFrame.Series{`0,System.Double})">
<summary>
 [category:Operators]
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharp.DataFrame.Series`2">
<summary>
 The type `Series&lt;K, V&gt;` represents a data series consisting of values `V` indexed by
 keys `K`. The keys of a series may or may not be ordered 
</summary>
</member>
<member name="F:FSharp.DataFrame.UnionBehavior.Exclusive">
<summary>
 When there are values available in both series that are being unioned, raise an exception.
</summary>
</member>
<member name="F:FSharp.DataFrame.UnionBehavior.PreferRight">
<summary>
 When there are values available in both series that are being unioned, prefer the right value.
</summary>
</member>
<member name="F:FSharp.DataFrame.UnionBehavior.PreferLeft">
<summary>
 When there are values available in both series that are being unioned, prefer the left value.
</summary>
</member>
<member name="">

</member>
<member name="T:FSharp.DataFrame.UnionBehavior">
<summary>
 This enumeration specifeis the behavior of `Union` operation on series when there are
 overlapping keys in two series that are being unioned. The options include prefering values
 from the left/right series or throwing an exception when both values are available.
</summary>
</member>
<member name="M:FSharp.DataFrame.Vector.CreateMissing``1(System.Collections.Generic.IEnumerable{System.Nullable{``0}})">
<summary>
 Creates a vector that stores the specified data in an array.
 Values such as `null` and `Double.NaN` are turned into missing values.
</summary>
</member>
<member name="M:FSharp.DataFrame.Vector.CreateMissing``1(System.Collections.Generic.IEnumerable{FSharp.DataFrame.OptionalValue{``0}})">
<summary>
 Creates a vector that stores the specified data in an array.
 Values such as `null` and `Double.NaN` are turned into missing values.
</summary>
</member>
<member name="M:FSharp.DataFrame.Vector.Create``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
 Creates a vector that stores the specified data in an array.
 Values such as `null` and `Double.NaN` are turned into missing values.
</summary>
</member>
<member name="M:FSharp.DataFrame.Vector.Create``1(``0[])">
<summary>
 Creates a vector that stores the specified data in an array.
 Values such as `null` and `Double.NaN` are turned into missing values.
</summary>
</member>
<member name="T:FSharp.DataFrame.Vector">
<summary>
 Type that provides access to creating vectors (represented as arrays)
</summary>
</member>
<member name="T:FSharp.DataFrame.opt`1">
<summary>
 A type alias for the `OptionalValue&lt;T&gt;` type. The type alias can be used
 to make F# type definitions that use optional values directly more succinct.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharp.DataFrame.Addressing.|IntAddress|(FSharp.DataFrame.Addressing.Address)">
<summary>
 ArrayVectors assume that the address is an integer
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharp.DataFrame.Addressing.AddressModule">

</member>
<member name="T:FSharp.DataFrame.Addressing">
<summary>
 An `Address` value is used as an interface between vectors and indices. The index maps
 keys of various types to address, which is then used to get a value from the vector.
 
 ## Details

 In the most common case, the address will be `int` (and can represent index in an array),
 but it is possible to imagine other addresses - `int64` could be used with arrays of 
 arrays (to handle very large data). A lazily loaded vector might use something completely
 different (perhaps a date?). In principle this should be generic, but that is hard to do - 
 we want something like:

     Series.Create : \forall &apos;TKey, &apos;TValue. \exists &apos;TAddress. 
       Index&lt;&apos;TKey, &apos;TAddress&gt; * Vector&lt;&apos;TAddress, &apos;TValue&gt; -&gt; Series&lt;&apos;TKey, &apos;TValue&gt;

 The .NET encoding of this is a bit ugly. So instead, we just have `Address` which currently
 supports `Int` and `Int64`, but we keep all operations in the `Address` module, so that
 this can be easily extended.
</summary>
</member>
<member name="M:FSharp.DataFrame.DataSegment.GetKind``1(FSharp.DataFrame.DataSegment{``0})">
<summary>
 Returns the kind property of the specified `DataSegment&lt;T&gt;`
</summary>
</member>
<member name="M:FSharp.DataFrame.DataSegment.GetData``1(FSharp.DataFrame.DataSegment{``0})">
<summary>
 Returns the data property of the specified `DataSegment&lt;T&gt;`
</summary>
</member>
<member name="M:FSharp.DataFrame.DataSegment.|Complete|Incomplete|``1(FSharp.DataFrame.DataSegment{``0})">
<summary>
 Complete active pattern that makes it possible to write functions that behave 
 differently for complete and incomplete segments. For example, the following 
 returns zero for incomplete segments:

     let sumSegmentOrZero = function
       | DataSegment.Complete(value) -&gt; Series.sum value
       | DataSegment.Incomplete _ -&gt; 0.0

</summary>
</member>
<member name="M:FSharp.DataFrame.DataSegment.|Any|``1(FSharp.DataFrame.DataSegment{``0})">
<summary>
 A complete active pattern that extracts the kind and data from a `DataSegment`
 value. This makes it easier to write functions that only need data:

    let sumAny = function DataSegment.Any(_, data) -&gt; Series.sum data

</summary>
</member>
<member name="T:FSharp.DataFrame.DataSegment">
<summary>
 Provides helper functions and active patterns for working with `DataSegment` values
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharp.DataFrame.Delayed.DelayedIndexBuilder">
<summary>
 Delayed index builder - this is where interesting things happen. Most operations
 are still delegated to LinearIndexBuilder, but the `GetRange` method looks at the
 index and if it is DelayedIndex, then it uses the `Source` to build a new `Source`
 with a restricted range.
</summary>
</member>
<member name="">

</member>
<member name="T:FSharp.DataFrame.Delayed.DelayedIndexFunction`2">
<summary>
 A polymorphic function that is passed to IDelayedIndex.Invoke
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharp.DataFrame.Delayed.IDelayedIndex`1">
<summary>
 In the DelayedIndexBuilder, we do not know the type of values, so this 
 is a less generic interface that gives us a way for accessing it...
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharp.DataFrame.Delayed.DelayedIndex`2">
<summary>
 Delayed index that is lnked to a DelayedSource specified during construction
 (This simply delegates all operations to the &apos;source.Keys&apos; index)
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharp.DataFrame.Delayed.DelayedVector`2">
<summary>
 A delayed vector that is linked to a DelayedSource specified during construction
 (This simply delegates all operations to the &apos;source.Values&apos; vector)
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharp.DataFrame.Delayed.DelayedSource`2">
<summary>
 This type represents data source for constructing delayed series. To construct
 a delayed series, use `DelayedSeries.Create` (this creates index and vector 
 linked to this `DelayedSource`).
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharp.DataFrame.Delayed.Ranges.flattenRanges``1(``0,``0,System.Collections.Generic.IComparer{``0},FSharp.DataFrame.Delayed.Ranges.Ranges{``0})">
<summary>
 Returns an ordered sequence of exclusive ranges
</summary>
</member>
<member name="M:FSharp.DataFrame.Delayed.Ranges.contains``1(System.Collections.Generic.IComparer{``0},``0,FSharp.DataFrame.Delayed.Ranges.Ranges{``0})">
<summary>
 Test if a range contains the specified value
</summary>
</member>
<member name="M:FSharp.DataFrame.Delayed.Ranges.containsSub``1(System.Collections.Generic.IComparer{``0},``0,``0,FSharp.DataFrame.Delayed.Ranges.Ranges{``0})">
<summary>
 Test if a range contains the specified sub-range
 (the function assumes that the sub-range is smaller than any range in the input)
</summary>
</member>
<member name="">

</member>
<member name="T:FSharp.DataFrame.Delayed.Ranges">
<summary>
 Module that contains functions for working with ranges - most importantly
 it handles flattening of trees constructed by unioning &amp; intersecting ranges
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharp.DataFrame.ExpressionHelpers">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharp.DataFrame.FSharpFrameExtensions.Frame.ofRowsOrdinal.Static``3(System.Collections.Generic.IEnumerable{``0})">
<summary>
 Creates a data frame with ordinal Integer index from a sequence of rows.
 The column indices of individual rows are unioned, so if a row has fewer
 columns, it will be successfully added, but there will be missing values.
</summary>
</member>
<member name="M:FSharp.DataFrame.FSharpFrameExtensions.Frame.readCsv.Static(System.IO.Stream,Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{System.String})">
<summary>
 Load data frame from a CSV file. The operation automatically reads column names from the 
 CSV file (if they are present) and infers the type of values for each column. Columns
 of primitive types (`int`, `float`, etc.) are converted to the right type. Columns of other
 types (such as dates) are not converted automatically.

 ## Parameters

  * `stream` - Specifies the input stream, opened at the beginning of CSV data
  * `inferTypes` - Specifies whether the method should attempt to infer types
    of columns automatically (set this to `false` if you want to specify schema)
  * `inferRows` - If `inferTypes=true`, this parameter specifies the number of
    rows to use for type inference. The default value is 0, meaninig all rows.
  * `schema` - A string that specifies CSV schema. See the documentation for 
    information about the schema format.
  * `separators` - A string that specifies one or more (single character) separators
    that are used to separate columns in the CSV file. Use for example `&quot;;&quot;` to 
    parse semicolon separated files.
  * `culture` - Specifies the name of the culture that is used when parsing 
    values in the CSV file (such as `&quot;en-US&quot;`). The default is invariant culture. 
</summary>
</member>
<member name="M:FSharp.DataFrame.FSharpFrameExtensions.Frame.readCsv.Static(System.String,Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{System.String})">
<summary>
 Load data frame from a CSV file. The operation automatically reads column names from the 
 CSV file (if they are present) and infers the type of values for each column. Columns
 of primitive types (`int`, `float`, etc.) are converted to the right type. Columns of other
 types (such as dates) are not converted automatically.

 ## Parameters

  * `location` - Specifies a file name or an web location of the resource.
  * `inferTypes` - Specifies whether the method should attempt to infer types
    of columns automatically (set this to `false` if you want to specify schema)
  * `inferRows` - If `inferTypes=true`, this parameter specifies the number of
    rows to use for type inference. The default value is 0, meaninig all rows.
  * `schema` - A string that specifies CSV schema. See the documentation for 
    information about the schema format.
  * `separators` - A string that specifies one or more (single character) separators
    that are used to separate columns in the CSV file. Use for example `&quot;;&quot;` to 
    parse semicolon separated files.
  * `culture` - Specifies the name of the culture that is used when parsing 
    values in the CSV file (such as `&quot;en-US&quot;`). The default is invariant culture. 
</summary>
</member>
<member name="M:FSharp.DataFrame.FSharpFrameExtensions.op_Dollar``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},FSharp.DataFrame.Series{``2,``0})">
<summary>
 Custom operator that can be used for applying fuction to all elements of 
 a series. This provides a nicer syntactic sugar for the `Series.mapValues` 
 function. For example:

     // Given a float series and a function on floats
     let s1 = Series.ofValues [ 1.0 .. 10.0 ]
     let adjust v = max 10.0 v

     // Apply &quot;adjust (v + v)&quot; to all elements
     adjust $ (s1 + s1)

</summary>
</member>
<member name="">

</member>
<member name="M:FSharp.DataFrame.FSharpFrameExtensions.op_EqualsGreater``2(``0,``1)">
<summary>
 Custom operator that can be used when constructing series from observations
 or frames from key-row or key-column pairs. The operator simply returns a 
 tuple, but it provides a more convenient syntax. For example:

     Series.ofObservations [ &quot;k1&quot; =&gt; 1; &quot;k2&quot; =&gt; 15 ]

</summary>
</member>
<member name="T:FSharp.DataFrame.FSharpFrameExtensions">

</member>
<member name="M:FSharp.DataFrame.FSharpIndexExtensions.Index.ofUnorderedKeys``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
 Create an index from a sequence of keys and assume they are not sorted
 (the resulting index is also not sorted).
</summary>
</member>
<member name="M:FSharp.DataFrame.FSharpIndexExtensions.Index.ofKeys``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
 Create an index from a sequence of keys and check if they are sorted or not
</summary>
</member>
<member name="T:FSharp.DataFrame.FSharpIndexExtensions.Index">
<summary>
 Type that provides a simple access to creating indices represented
 using the built-in `LinearVector` type.
</summary>
</member>
<member name="T:FSharp.DataFrame.FSharpIndexExtensions">
<summary>
 Defines non-generic `Index` type that provides functions for building indices
 (hard-bound to `LinearIndexBuilder` type). In F#, the module is automatically opened
 using `AutoOpen`. The methods are not designed for the use from C#.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharp.DataFrame.FSharpSeriesExtensions">

</member>
<member name="M:FSharp.DataFrame.FSharpVectorExtensions.Vector.ofValues``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
 Creates a vector that stores the specified data in an array.
 Values such as `null` and `Double.NaN` are turned into missing values.
</summary>
</member>
<member name="M:FSharp.DataFrame.FSharpVectorExtensions.Vector.ofValues``1(``0[])">
<summary>
 Creates a vector that stores the specified data in an array.
 Values such as `null` and `Double.NaN` are turned into missing values.
</summary>
</member>
<member name="M:FSharp.DataFrame.FSharpVectorExtensions.Vector.ofOptionalValues``1(System.Collections.Generic.IEnumerable{FSharp.DataFrame.OptionalValue{``0}})">
<summary>
 Missing values can be specified explicitly as `OptionalValue.Missing`, but 
 other values such as `null` and `Double.NaN` are turned into missing values too.
</summary>
</member>
<member name="M:FSharp.DataFrame.FSharpVectorExtensions.Vector.ofOptionalValues``1(System.Collections.Generic.IEnumerable{Microsoft.FSharp.Core.FSharpOption{``0}})">
<summary>
 Creates a vector that stores the specified data in an array.
 Missing values can be specified explicitly as `None`, but other values 
 such as `null` and `Double.NaN` are turned into missing values too.
</summary>
</member>
<member name="T:FSharp.DataFrame.FSharpVectorExtensions.Vector">
<summary>
 Type that provides a simple access to creating vectors represented
 using the built-in `ArrayVector` type that stores the data in a 
 continuous block of memory.
</summary>
</member>
<member name="T:FSharp.DataFrame.FSharpVectorExtensions">
<summary>
 Defines non-generic `Vector` type that provides functions for building vectors
 (hard-bound to `ArrayVectorBuilder` type). In F#, the module is automatically opened
 using `AutoOpen`. The methods are not designed for the use from C#.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharp.DataFrame.FrameBuilder">

</member>
<member name="M:FSharp.DataFrame.FrameModule.rowsDense``2(FSharp.DataFrame.Frame{``0,``1})">
<summary>
 Returns the rows of the data frame that do not have any missing values. 
 The operation returns a series (indexed by the row keys of the source frame) 
 containing _series_ representing individual row of the frame. This is similar 
 to `Rows`, but it skips rows that contain missing value in _any_ column.

 ## Parameters
  - `frame` - An input data frame containing rows to be filtered

 [category:Missing values]
</summary>
</member>
<member name="M:FSharp.DataFrame.FrameModule.colsDense``2(FSharp.DataFrame.Frame{``0,``1})">
<summary>
 Returns the columns of the data frame that do not have any missing values.
 The operation returns a series (indexed by the column keys of the source frame) 
 containing _series_ representing individual columns of the frame. This is similar 
 to `Columns`, but it skips columns that contain missing value in _any_ row.

 ## Parameters
  - `frame` - An input data frame containing columns to be filtered

 [category:Missing values]
</summary>
</member>
<member name="M:FSharp.DataFrame.FrameModule.dropSparseCols``2(FSharp.DataFrame.Frame{``0,``1})">
<summary>
 Creates a new data frame that contains only those columns of the original 
 data frame that are _dense_, meaning that they have a value for each row.
 The resulting data frame has the same number of rows, but may have 
 fewer columns (or no columns at all).

 ## Parameters
  - `frame` - An input data frame that is to be filtered

 [category:Missing values]
</summary>
</member>
<member name="M:FSharp.DataFrame.FrameModule.dropSparseRows``2(FSharp.DataFrame.Frame{``0,``1})">
<summary>
 Creates a new data frame that contains only those rows of the original 
 data frame that are _dense_, meaning that they have a value for each column.
 The resulting data frame has the same number of columns, but may have 
 fewer rows (or no rows at all).
 
 ## Parameters
  - `frame` - An input data frame that is to be filtered

 [category:Missing values]
</summary>
</member>
<member name="M:FSharp.DataFrame.FrameModule.fillMissingUsing``3(Microsoft.FSharp.Core.FSharpFunc{FSharp.DataFrame.Series{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``0,``1}},FSharp.DataFrame.Frame{``0,``2})">
<summary>
 Fill missing values in the frame using the specified function. The specified
 function is called with all series and keys for which the frame does not 
 contain value and the result of the call is used in place of the missing value.

 The operation is only applied to columns (series) that contain values of the
 same type as the return type of the provided filling function. The operation 
 does not attempt to convert between numeric values (so a series containing 
 `float` will not be converted to a series of `int`).

 ## Parameters
  - `frame` - An input data frame that is to be filled
  - `f` - A function that takes a series `Series&lt;R, T&gt;` together with a key `K` 
    in the series and generates a value to be used in a place where the original 
    series contains a missing value.

 [category:Missing values]
</summary>
</member>
<member name="M:FSharp.DataFrame.FrameModule.fillMissing``2(FSharp.DataFrame.Direction,FSharp.DataFrame.Frame{``0,``1})">
<summary>
 Fill missing values in the data frame with the nearest available value
 (using the specified direction). Note that the frame may still contain
 missing values after call to this function (e.g. if the first value is not available
 and we attempt to fill series with previous values). This operation can only be
 used on ordered frames.

 ## Parameters
  - `frame` - An input data frame that is to be filled
  - `direction` - Specifies the direction used when searching for 
    the nearest available value. `Backward` means that we want to
    look for the first value with a smaller key while `Forward` searches
    for the nearest greater key.

 [category:Missing values]
</summary>
</member>
<member name="M:FSharp.DataFrame.FrameModule.fillMissingWith``3(``0,FSharp.DataFrame.Frame{``1,``2})">
<summary>
 Fill missing values of a given type in the frame with a constant value.
 The operation is only applied to columns (series) that contain values of the
 same type as the provided filling value. The operation does not attempt to 
 convert between numeric values (so a series containing `float` will not be
 converted to a series of `int`).

 ## Parameters
  - `frame` - An input data frame that is to be filled
  - `value` - A constant value that is used to fill all missing values

 [category:Missing values]
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharp.DataFrame.FrameModule.JoinAlign``2(FSharp.DataFrame.JoinKind,FSharp.DataFrame.Lookup,FSharp.DataFrame.Frame{``0,``1},FSharp.DataFrame.Frame{``0,``1})">
<summary>
 Join two frames using the specified kind of join and 
 the specified lookup semantics.
</summary>
</member>
<member name="M:FSharp.DataFrame.FrameModule.Join``2(FSharp.DataFrame.JoinKind,FSharp.DataFrame.Frame{``0,``1},FSharp.DataFrame.Frame{``0,``1})">
<summary>
 Join two frames using the specified kind of join. This function uses
 exact matching on keys. If you want to align nearest smaller or greater
 keys in left or outer join, use `joinAlign`. 
</summary>
</member>
<member name="M:FSharp.DataFrame.FrameModule.renameCols``3(System.Collections.Generic.IEnumerable{``0},FSharp.DataFrame.Frame{``1,``2})">
<summary>
 Creates a new data frame that uses the specified list of keys as a new column index.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharp.DataFrame.FrameModule.indexRows``3(``0,FSharp.DataFrame.Frame{``1,``0})">
<summary>
 Creates a new data frame that uses the specified column as an row index.
</summary>
</member>
<member name="M:FSharp.DataFrame.FrameModule.OrderColumns``2(FSharp.DataFrame.Frame{``0,``1})">
<summary>
 Returns a data frame that contains the same data as the argument, 
 but whose columns are ordered series. This allows using inexact lookup
 for columns (e.g. using `lookupCol`) or inexact left/right joins.
</summary>
</member>
<member name="M:FSharp.DataFrame.FrameModule.OrderRows``2(FSharp.DataFrame.Frame{``0,``1})">
<summary>
 Returns a data frame that contains the same data as the argument, 
 but whose rows are ordered series. This allows using inexact lookup
 for rows (e.g. using `lookupRow`) or inexact left/right joins.
</summary>
</member>
<member name="M:FSharp.DataFrame.FrameModule.LookupRow``3(``0,FSharp.DataFrame.Lookup,FSharp.DataFrame.Frame{``0,``1})">
<summary>
 Returns a specified row from a data frame. If the data frame has 
 ordered row index, the lookup semantics can be used to get row with 
 nearest greater/smaller key. For exact semantics, you can use `getSeries`.
</summary>
</member>
<member name="M:FSharp.DataFrame.FrameModule.LookupColumn``3(``0,FSharp.DataFrame.Lookup,FSharp.DataFrame.Frame{``1,``0})">
<summary>
 Returns a specified series (column) from a data frame. If the data frame has 
 ordered column index, the lookup semantics can be used to get series
 with nearest greater/smaller key. For exact semantics, you can use `getSeries`.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharp.DataFrame.FrameModule.GetRow``3(``0,FSharp.DataFrame.Frame{``0,``1})">
<summary>
 Returns a specified row from a data frame. This 
 function uses exact matching semantics. Use `lookupRow` if you
 want to use inexact matching (e.g. on dates)
</summary>
</member>
<member name="M:FSharp.DataFrame.FrameModule.GetColumn``3(``0,FSharp.DataFrame.Frame{``1,``0})">
<summary>
 Returns a specified series (column) from a data frame. This 
 function uses exact matching semantics. Use `lookupSeries` if you
 want to use inexact matching (e.g. on dates)
</summary>
</member>
<member name="M:FSharp.DataFrame.FrameModule.ReplaceColumn``2(``0,FSharp.DataFrame.ISeries{``1},FSharp.DataFrame.Frame{``1,``0})">
<summary>
 Creates a new data frame where the specified column is repalced
 with a new series. (If the series does not exist, only the new
 series is added.)
</summary>
</member>
<member name="M:FSharp.DataFrame.FrameModule.DropColumn``2(``0,FSharp.DataFrame.Frame{``1,``0})">
<summary>
 Creates a new data frame that contains all data from the original
 data frame without the specified series (column).
</summary>
</member>
<member name="M:FSharp.DataFrame.FrameModule.Rows``2(FSharp.DataFrame.Frame{``0,``1})">
<summary>
 Returns the rows of the data frame as a series (indexed by 
 the row keys of the source frame) containing _series_ representing
 individual row of the frame.
</summary>
</member>
<member name="M:FSharp.DataFrame.FrameModule.Columns``2(FSharp.DataFrame.Frame{``0,``1})">
<summary>
 Returns the columns of the data frame as a series (indexed by 
 the column keys of the source frame) containing _series_ representing
 individual columns of the frame.
</summary>
</member>
<member name="M:FSharp.DataFrame.FrameModule.Append``2(FSharp.DataFrame.Frame{``0,``1},FSharp.DataFrame.Frame{``0,``1})">
<summary>
 Append two data frames. The columns of the resulting data frame
 will be the union of columns of the two data frames. The row keys
 may overlap, but the values must not - if there is a value for a
 certain column, at the same row index in both data frames, an exception
 is thrown. 
</summary>
</member>
<member name="M:FSharp.DataFrame.FrameModule.AddColumn``3(``0,FSharp.DataFrame.Series{``1,``2},FSharp.DataFrame.Frame{``1,``0})">
<summary>
 Creates a new data frame that contains all data from 
 the original data frame, together with additional series.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharp.DataFrame.FrameModule.countCols``2(FSharp.DataFrame.Frame{``0,``1})">
<summary>
 Returns the total number of column keys in the specified frame. This returns
 the total length of columns, including keys for which there is no 
 data available.
</summary>
</member>
<member name="M:FSharp.DataFrame.FrameModule.countRows``2(FSharp.DataFrame.Frame{``0,``1})">
<summary>
 Returns the total number of row keys in the specified frame. This returns
 the total length of the row series, including keys for which there is no 
 value available.
</summary>
</member>
<member name="T:FSharp.DataFrame.FrameModule">

</member>
<member name="M:FSharp.DataFrame.FrameUtilsModule.readCsv(System.IO.TextReader,Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.String},System.String,Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{System.String})">
<summary>
 Load data from a CSV file using F# Data API
</summary>
</member>
<member name="T:FSharp.DataFrame.FrameUtilsModule">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharp.DataFrame.Indices.BoundaryBehavior">
<summary>
 Specifies the boundary behavior for the `IIndexBuilder.GetRange` operation
 (whether the boundary elements should be included or not)
</summary>
</member>
<member name="M:FSharp.DataFrame.Indices.IIndexBuilder.WithIndex``2(FSharp.DataFrame.Indices.IIndex{``0},Microsoft.FSharp.Core.FSharpFunc{FSharp.DataFrame.Addressing.Address,FSharp.DataFrame.OptionalValue{``1}},FSharp.DataFrame.Vectors.VectorConstruction)">
<summary>
 Create a new index by picking a new key value for each key in the original index
 (used e.g. when we have a frame and want to use specified column as a new index).
</summary>
</member>
<member name="M:FSharp.DataFrame.Indices.IIndexBuilder.Union``1(System.Tuple{FSharp.DataFrame.Indices.IIndex{``0},FSharp.DataFrame.Vectors.VectorConstruction},System.Tuple{FSharp.DataFrame.Indices.IIndex{``0},FSharp.DataFrame.Vectors.VectorConstruction})">
<summary>
 Creates a union of two indices and builds corresponding vector transformations
 for both vectors that match the left and the right index.
</summary>
</member>
<member name="M:FSharp.DataFrame.Indices.IIndexBuilder.Resample``3(FSharp.DataFrame.Indices.IIndex{``0},System.Collections.Generic.IEnumerable{``0},FSharp.DataFrame.Direction,FSharp.DataFrame.Vectors.VectorConstruction,Microsoft.FSharp.Core.FSharpFunc{System.Tuple{``1,System.Tuple{FSharp.DataFrame.Indices.IIndex{``0},FSharp.DataFrame.Vectors.VectorConstruction}},FSharp.DataFrame.OptionalValue{``2}},Microsoft.FSharp.Core.FSharpFunc{System.Tuple{``0,System.Tuple{FSharp.DataFrame.Indices.IIndex{``0},FSharp.DataFrame.Vectors.VectorConstruction}},``1})">
<summary>
 Aggregate data into non-overlapping chunks by aligning them to the
 specified keys. The second parameter specifies the direction. If it is
 `Direction.Forward` than the key is the first element of a chunk; for 
 `Direction.Backward`, the key is the last element (note that this does not 
 hold at the boundaries where values before/after the key may also be included)
</summary>
</member>
<member name="M:FSharp.DataFrame.Indices.IIndexBuilder.Reindex``1(FSharp.DataFrame.Indices.IIndex{``0},FSharp.DataFrame.Indices.IIndex{``0},FSharp.DataFrame.Lookup,FSharp.DataFrame.Vectors.VectorConstruction)">
<summary>
 Given an old index and a new index, build a vector transformation that reorders
 elements from a vector associated with the old index so that they match the new
 index. When finding element location in the new index, the provided `Lookup` strategy
 is used. This is used, for example, when doing left/right join (to align the new data
 with another index) or when selecting multiple keys (`Series.lookupAll`).
</summary>
</member>
<member name="M:FSharp.DataFrame.Indices.IIndexBuilder.Project``1(FSharp.DataFrame.Indices.IIndex{``0})">
<summary>
 When we perform some projection on the vector (e.g. `Series.map`), then we may also
 need to perform some transformation on the index (because it will typically turn delayed
 index into an evaluated index). This operation represents that - it should return 
 (evaluated) index with the same keys.
</summary>
</member>
<member name="M:FSharp.DataFrame.Indices.IIndexBuilder.OrderIndex``1(System.Tuple{FSharp.DataFrame.Indices.IIndex{``0},FSharp.DataFrame.Vectors.VectorConstruction})">
<summary>
 Order (possibly unordered) index and return transformation that reorders vector
</summary>
</member>
<member name="M:FSharp.DataFrame.Indices.IIndexBuilder.LookupLevel``1(System.Tuple{FSharp.DataFrame.Indices.IIndex{``0},FSharp.DataFrame.Vectors.VectorConstruction},FSharp.DataFrame.ICustomLookup{``0})">
<summary>
 Get items associated with the specified key from the index. This method takes
 `ICustomLookup&lt;K&gt;` which provides an implementation of `ICustomKey&lt;K&gt;`. This 
 is used for custom equality testing (for example, when getting a level of a hierarchical index)
</summary>
</member>
<member name="M:FSharp.DataFrame.Indices.IIndexBuilder.Intersect``1(System.Tuple{FSharp.DataFrame.Indices.IIndex{``0},FSharp.DataFrame.Vectors.VectorConstruction},System.Tuple{FSharp.DataFrame.Indices.IIndex{``0},FSharp.DataFrame.Vectors.VectorConstruction})">
<summary>
 Creates an interesection of two indices and builds corresponding vector transformations
 for both vectors that match the left and the right index.
</summary>
</member>
<member name="M:FSharp.DataFrame.Indices.IIndexBuilder.GroupBy``3(FSharp.DataFrame.Indices.IIndex{``0},Microsoft.FSharp.Core.FSharpFunc{``0,FSharp.DataFrame.OptionalValue{``1}},FSharp.DataFrame.Vectors.VectorConstruction,Microsoft.FSharp.Core.FSharpFunc{System.Tuple{``1,System.Tuple{FSharp.DataFrame.Indices.IIndex{``0},FSharp.DataFrame.Vectors.VectorConstruction}},FSharp.DataFrame.OptionalValue{``2}})">
<summary>
 Group a (possibly unordered) index using the specified `keySelector` function.
 The operation builds a new index with the selected keys and a matching vector
 with values produced by the `valueSelector` function.
</summary>
</member>
<member name="M:FSharp.DataFrame.Indices.IIndexBuilder.GetRange``1(FSharp.DataFrame.Indices.IIndex{``0},Microsoft.FSharp.Core.FSharpOption{System.Tuple{``0,FSharp.DataFrame.Indices.BoundaryBehavior}},Microsoft.FSharp.Core.FSharpOption{System.Tuple{``0,FSharp.DataFrame.Indices.BoundaryBehavior}},FSharp.DataFrame.Vectors.VectorConstruction)">
<summary>
 Create a new index that represents sub-range of an existing index. The range is specified
 as a pair of options (when `None`, the original left/right boundary should be used) 
 that contain boundary behavior and the boundary key.
</summary>
</member>
<member name="M:FSharp.DataFrame.Indices.IIndexBuilder.DropItem``1(System.Tuple{FSharp.DataFrame.Indices.IIndex{``0},FSharp.DataFrame.Vectors.VectorConstruction},``0)">
<summary>
 Drop an item associated with the specified key from the index. 
</summary>
</member>
<member name="M:FSharp.DataFrame.Indices.IIndexBuilder.Create``1(System.Collections.Generic.IEnumerable{``0},Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
<summary>
 Create a new index using the specified keys. Optionally, the caller can specify
 if the index keys are ordered or not. When the value is not set, the construction
 should check and infer this from the data.
</summary>
</member>
<member name="M:FSharp.DataFrame.Indices.IIndexBuilder.Append``1(System.Tuple{FSharp.DataFrame.Indices.IIndex{``0},FSharp.DataFrame.Vectors.VectorConstruction},System.Tuple{FSharp.DataFrame.Indices.IIndex{``0},FSharp.DataFrame.Vectors.VectorConstruction},FSharp.DataFrame.Vectors.IVectorValueTransform)">
<summary>
 Append two indices and builds corresponding vector transformations
 for both vectors that match the left and the right index. If the indices
 are ordered, the ordering should be preserved (the keys should be aligned).
 The specified `IVectorValueTransform` defines how to deal with the case when
 a key is defined in both indices (i.e. which value should be in the new vector).
</summary>
</member>
<member name="M:FSharp.DataFrame.Indices.IIndexBuilder.Aggregate``3(FSharp.DataFrame.Indices.IIndex{``0},FSharp.DataFrame.Aggregation{``0},FSharp.DataFrame.Vectors.VectorConstruction,Microsoft.FSharp.Core.FSharpFunc{System.Tuple{FSharp.DataFrame.DataSegmentKind,System.Tuple{FSharp.DataFrame.Indices.IIndex{``0},FSharp.DataFrame.Vectors.VectorConstruction}},FSharp.DataFrame.OptionalValue{``1}},Microsoft.FSharp.Core.FSharpFunc{System.Tuple{FSharp.DataFrame.DataSegmentKind,System.Tuple{FSharp.DataFrame.Indices.IIndex{``0},FSharp.DataFrame.Vectors.VectorConstruction}},``2})">
<summary>
 Aggregate an ordered index into floating windows or chunks. 

 ## Parameters

  - `index` - Specifies the index to be aggregated
  - `aggregation` - Defines the kind of aggregation to apply (the type 
    is a discriminated union with a couple of cases)
  - `source` - Source vector construction to be transformed 
  - `valueSelector` - Given information about window/chunk (including 
    vector construction that can be used to build the data chunk), return
    a new value for the returned vector.
  - `keySelector` - Given information about window/chunk (including 
    vector construction that can be used to build the data chunk), return a key of the chunk/window.
</summary>
</member>
<member name="T:FSharp.DataFrame.Indices.IIndexBuilder">
<summary>
 A builder represents various ways of constructing index, either from keys or from
 other indices. The operations that build a new index from an existing index also 
 build `VectorConstruction` which specifies how to transform vectors aligned with the
 previous index to match the new index. The methods generally take `VectorConstruction`
 as an input, apply necessary transformations to it and return a new `VectorConstruction`.

 ## Example

 For example, given `index`, we can say:

     // Create an index that excludes the value 42
     let newIndex, vectorCmd = indexBuilder.DropItem(index, 42, VectorConstruction.Return(0))

     // Now we can transform multiple vectors (e.g. all frame columns) using &apos;vectorCmd&apos;
     // (the integer &apos;0&apos; in `Return` is an offset in the array of vector arguments)
     let newVector = vectorBuilder.Build(vectorCmd, [| vectorToTransform |])

</summary>
</member>
<member name="P:FSharp.DataFrame.Indices.IIndex`1.Range">
<summary>
 Returns the minimal and maximal address used in the index.
</summary>
</member>
<member name="P:FSharp.DataFrame.Indices.IIndex`1.Ordered">
<summary>
 Returns `true` if the index is ordered and `false` otherwise
</summary>
</member>
<member name="P:FSharp.DataFrame.Indices.IIndex`1.Mappings">
<summary>
 Returns all key-address mappings in the index
</summary>
</member>
<member name="P:FSharp.DataFrame.Indices.IIndex`1.Keys">
<summary>
 Returns a sequence of all keys in the index.
</summary>
</member>
<member name="P:FSharp.DataFrame.Indices.IIndex`1.KeyRange">
<summary>
 Returns the minimal and maximal key associated with the index.
 (the operation may fail for unordered indices)
</summary>
</member>
<member name="P:FSharp.DataFrame.Indices.IIndex`1.IsEmpty">
<summary>
 Returns whether the specified index is empty. This is equivalent to 
 testing if `Keys` are empty, but it does not have to evaluate delayed index.
</summary>
</member>
<member name="P:FSharp.DataFrame.Indices.IIndex`1.Comparer">
<summary>
 Returns a comparer associated with the values used by the current index.
</summary>
</member>
<member name="P:FSharp.DataFrame.Indices.IIndex`1.Builder">
<summary>
 Returns an index builder that canbe used for constructing new indices of the
 same kind as the current index (e.g. a lazy index returns a lazy index builder)
</summary>
</member>
<member name="M:FSharp.DataFrame.Indices.IIndex`1.Lookup(`0,FSharp.DataFrame.Lookup,Microsoft.FSharp.Core.FSharpFunc{FSharp.DataFrame.Addressing.Address,System.Boolean})">
<summary>
 Find the address associated with the specified key, or with the nearest
 key as specifeid by the `lookup` argument. The `condition` function is called
 when searching for keys to ask the caller whether the address should be returned
 (or whether to continue searching). This is used when searching for previous element
 in a series (where we need to check if a value at the address is available)
</summary>
</member>
<member name="M:FSharp.DataFrame.Indices.IIndex`1.KeyAt(FSharp.DataFrame.Addressing.Address)">
<summary>
 Performs reverse lookup - and returns key for a specified address
</summary>
</member>
<member name="T:FSharp.DataFrame.Indices.IIndex`1">
<summary>
 An interface that represents index mapping keys of some generic type `T` to locations
 of address `Address`. The `IIndex&lt;K&gt;` contains minimal set of operations that have to
 be supported by an index. This type should be only used directly when
 extending the DataFrame library and adding a new way of storing or loading data.
 Values of this type are constructed using the associated `IIndexBuilder` type.
</summary>
</member>
<member name="T:FSharp.DataFrame.Indices.SeriesConstruction`1">
<summary>
 Represents a pair of index and vector construction 
 (many of the index operations take/return an index together with a construction
 command that builds a vector matching with the index, so this type alias
 makes this more obvious)
</summary>
</member>
<member name="">

</member>
<member name="F:FSharp.DataFrame.Indices.Linear.FSharp.DataFrame.Indices.Linear.LinearIndexBuilder.indexBuilder">
<summary>
 Instance of the index builder (specialized to Int32 addresses)
</summary>
</member>
<member name="">

</member>
<member name="P:FSharp.DataFrame.Indices.Linear.LinearIndexBuilder.Instance">
<summary>
 Provides a global access to an instance of LinearIndexBuilder
</summary>
</member>
<member name="M:FSharp.DataFrame.Indices.Linear.LinearIndexBuilder.FSharp-DataFrame-Indices-IIndexBuilder-WithIndex``2(FSharp.DataFrame.Indices.IIndex{``0},Microsoft.FSharp.Core.FSharpFunc{FSharp.DataFrame.Addressing.Address,FSharp.DataFrame.OptionalValue{``1}},FSharp.DataFrame.Vectors.VectorConstruction)">
<summary>
 Build a new index by getting a key for each old key using the specified function
</summary>
</member>
<member name="M:FSharp.DataFrame.Indices.Linear.LinearIndexBuilder.FSharp-DataFrame-Indices-IIndexBuilder-Union``1(System.Tuple{FSharp.DataFrame.Indices.IIndex{``0},FSharp.DataFrame.Vectors.VectorConstruction},System.Tuple{FSharp.DataFrame.Indices.IIndex{``0},FSharp.DataFrame.Vectors.VectorConstruction})">
<summary>
 Union the index with another. For sorted indices, this needs to align the keys;
 for unordered, it appends new ones to the end.
</summary>
</member>
<member name="M:FSharp.DataFrame.Indices.Linear.LinearIndexBuilder.FSharp-DataFrame-Indices-IIndexBuilder-Resample``3(FSharp.DataFrame.Indices.IIndex{``0},System.Collections.Generic.IEnumerable{``0},FSharp.DataFrame.Direction,FSharp.DataFrame.Vectors.VectorConstruction,Microsoft.FSharp.Core.FSharpFunc{System.Tuple{``1,System.Tuple{FSharp.DataFrame.Indices.IIndex{``0},FSharp.DataFrame.Vectors.VectorConstruction}},FSharp.DataFrame.OptionalValue{``2}},Microsoft.FSharp.Core.FSharpFunc{System.Tuple{``0,System.Tuple{FSharp.DataFrame.Indices.IIndex{``0},FSharp.DataFrame.Vectors.VectorConstruction}},``1})">
<summary>
 Create chunks based on the specified key sequence
</summary>
</member>
<member name="M:FSharp.DataFrame.Indices.Linear.LinearIndexBuilder.FSharp-DataFrame-Indices-IIndexBuilder-Reindex``1(FSharp.DataFrame.Indices.IIndex{``0},FSharp.DataFrame.Indices.IIndex{``0},FSharp.DataFrame.Lookup,FSharp.DataFrame.Vectors.VectorConstruction)">
<summary>
 Reorder elements in the index to match with another index ordering
</summary>
</member>
<member name="M:FSharp.DataFrame.Indices.Linear.LinearIndexBuilder.FSharp-DataFrame-Indices-IIndexBuilder-Project``1(FSharp.DataFrame.Indices.IIndex{``0})">
<summary>
 Linear index is always fully evaluated - just return it
</summary>
</member>
<member name="M:FSharp.DataFrame.Indices.Linear.LinearIndexBuilder.FSharp-DataFrame-Indices-IIndexBuilder-OrderIndex``1(System.Tuple{FSharp.DataFrame.Indices.IIndex{``0},FSharp.DataFrame.Vectors.VectorConstruction})">
<summary>
 Order index and build vector transformation 
</summary>
</member>
<member name="">

</member>
<member name="M:FSharp.DataFrame.Indices.Linear.LinearIndexBuilder.FSharp-DataFrame-Indices-IIndexBuilder-Intersect``1(System.Tuple{FSharp.DataFrame.Indices.IIndex{``0},FSharp.DataFrame.Vectors.VectorConstruction},System.Tuple{FSharp.DataFrame.Indices.IIndex{``0},FSharp.DataFrame.Vectors.VectorConstruction})">
<summary>
 Intersect the index with another. This is the same as
 Union, but we filter &amp; only return keys present in both sequences.
</summary>
</member>
<member name="M:FSharp.DataFrame.Indices.Linear.LinearIndexBuilder.FSharp-DataFrame-Indices-IIndexBuilder-GroupBy``3(FSharp.DataFrame.Indices.IIndex{``0},Microsoft.FSharp.Core.FSharpFunc{``0,FSharp.DataFrame.OptionalValue{``1}},FSharp.DataFrame.Vectors.VectorConstruction,Microsoft.FSharp.Core.FSharpFunc{System.Tuple{``1,System.Tuple{FSharp.DataFrame.Indices.IIndex{``0},FSharp.DataFrame.Vectors.VectorConstruction}},FSharp.DataFrame.OptionalValue{``2}})">
<summary>
 Group an (un)ordered index
</summary>
</member>
<member name="M:FSharp.DataFrame.Indices.Linear.LinearIndexBuilder.FSharp-DataFrame-Indices-IIndexBuilder-GetRange``1(FSharp.DataFrame.Indices.IIndex{``0},Microsoft.FSharp.Core.FSharpOption{System.Tuple{``0,FSharp.DataFrame.Indices.BoundaryBehavior}},Microsoft.FSharp.Core.FSharpOption{System.Tuple{``0,FSharp.DataFrame.Indices.BoundaryBehavior}},FSharp.DataFrame.Vectors.VectorConstruction)">
<summary>
 Get a new index representing a sub-index of the current one
 (together with a transformation that should be applied to a vector)
</summary>
</member>
<member name="M:FSharp.DataFrame.Indices.Linear.LinearIndexBuilder.FSharp-DataFrame-Indices-IIndexBuilder-DropItem``1(System.Tuple{FSharp.DataFrame.Indices.IIndex{``0},FSharp.DataFrame.Vectors.VectorConstruction},``0)">
<summary>
 Drop the specified item from the index
</summary>
</member>
<member name="M:FSharp.DataFrame.Indices.Linear.LinearIndexBuilder.FSharp-DataFrame-Indices-IIndexBuilder-Create``1(System.Collections.Generic.IEnumerable{``0},Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
<summary>
 Create an index from the specified data
</summary>
</member>
<member name="M:FSharp.DataFrame.Indices.Linear.LinearIndexBuilder.FSharp-DataFrame-Indices-IIndexBuilder-Append``1(System.Tuple{FSharp.DataFrame.Indices.IIndex{``0},FSharp.DataFrame.Vectors.VectorConstruction},System.Tuple{FSharp.DataFrame.Indices.IIndex{``0},FSharp.DataFrame.Vectors.VectorConstruction},FSharp.DataFrame.Vectors.IVectorValueTransform)">
<summary>
 Append is similar to union, but it also combines the vectors using the specified
 vector transformation.
</summary>
</member>
<member name="M:FSharp.DataFrame.Indices.Linear.LinearIndexBuilder.FSharp-DataFrame-Indices-IIndexBuilder-Aggregate``3(FSharp.DataFrame.Indices.IIndex{``0},FSharp.DataFrame.Aggregation{``0},FSharp.DataFrame.Vectors.VectorConstruction,Microsoft.FSharp.Core.FSharpFunc{System.Tuple{FSharp.DataFrame.DataSegmentKind,System.Tuple{FSharp.DataFrame.Indices.IIndex{``0},FSharp.DataFrame.Vectors.VectorConstruction}},FSharp.DataFrame.OptionalValue{``1}},Microsoft.FSharp.Core.FSharpFunc{System.Tuple{FSharp.DataFrame.DataSegmentKind,System.Tuple{FSharp.DataFrame.Indices.IIndex{``0},FSharp.DataFrame.Vectors.VectorConstruction}},``2})">
<summary>
 Aggregate ordered index
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharp.DataFrame.Indices.Linear.LinearIndexBuilder">
<summary>
 Index builder object that is associated with `LinearIndex&lt;K&gt;` type. The builder
 provides operations for manipulating linear indices (and the associated vectors).
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:FSharp.DataFrame.Indices.Linear.LinearIndex`1.Range">
<summary>
 Returns the range used by the index
</summary>
</member>
<member name="P:FSharp.DataFrame.Indices.Linear.LinearIndex`1.Ordered">
<summary>
 Are the keys of the index ordered?
</summary>
</member>
<member name="P:FSharp.DataFrame.Indices.Linear.LinearIndex`1.Mappings">
<summary>
 Returns all mappings of the index (key -&gt; address) 
</summary>
</member>
<member name="P:FSharp.DataFrame.Indices.Linear.LinearIndex`1.KeysArray">
<summary>
 Exposes keys array for use in the index builder
</summary>
</member>
<member name="">

</member>
<member name="P:FSharp.DataFrame.Indices.Linear.LinearIndex`1.KeyRange">
<summary>
 Returns the range of keys - makes sense only for ordered index
</summary>
</member>
<member name="P:FSharp.DataFrame.Indices.Linear.LinearIndex`1.IsEmpty">
<summary>
 Returns whether the specified index is empty
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharp.DataFrame.Indices.Linear.LinearIndex`1.FSharp-DataFrame-Indices-IIndex`1-Lookup(`0,FSharp.DataFrame.Lookup,Microsoft.FSharp.Core.FSharpFunc{FSharp.DataFrame.Addressing.Address,System.Boolean})">
<summary>
 Get the address for the specified key.
 The &apos;semantics&apos; specifies fancy lookup methods.
</summary>
</member>
<member name="M:FSharp.DataFrame.Indices.Linear.LinearIndex`1.FSharp-DataFrame-Indices-IIndex`1-KeyAt(FSharp.DataFrame.Addressing.Address)">
<summary>
 Perform reverse lookup and return key for an address
</summary>
</member>
<member name="M:FSharp.DataFrame.Indices.Linear.LinearIndex`1.GetHashCode">
<summary>
 Implement structural hashing against another index
</summary>
</member>
<member name="M:FSharp.DataFrame.Indices.Linear.LinearIndex`1.Equals(System.Object)">
<summary>
 Implements structural equality check against another index
</summary>
</member>
<member name="">

</member>
<member name="T:FSharp.DataFrame.Indices.Linear.LinearIndex`1">
<summary>
 An index that maps keys `K` to offsets `Address`. The keys cannot be duplicated.
 The construction checks if the keys are ordered (using the provided or the default
 comparer for `K`) and disallows certain operations on unordered indices.
</summary>
</member>
<member name="">

</member>
<member name="T:FSharp.DataFrame.Internal.IFsiFormattable">
<summary>
 An interface implemented by types that support nice formatting for F# Interactive
 (The `FSharp.DataFrame.fsx` file registers an FSI printer using this interface.)
</summary>
</member>
<member name="">

</member>
<member name="P:FSharp.DataFrame.Internal.Formatting.EndInlineItemCount">
<summary>
 Maximal number of items to be printed at the end of an inline formatted series/frame
</summary>
</member>
<member name="P:FSharp.DataFrame.Internal.Formatting.StartInlineItemCount">
<summary>
 Maximal number of items to be printed at the beginning of an inline formatted series/frame
</summary>
</member>
<member name="P:FSharp.DataFrame.Internal.Formatting.EndItemCount">
<summary>
 Maximal number of items to be printed at the end of a series/frame
</summary>
</member>
<member name="P:FSharp.DataFrame.Internal.Formatting.StartItemCount">
<summary>
 Maximal number of items to be printed at the beginning of a series/frame
</summary>
</member>
<member name="T:FSharp.DataFrame.Internal.Formatting">

</member>
<member name="M:FSharp.DataFrame.Internal.Seq.alignWithoutOrdering``2(System.Collections.Generic.IEnumerable{System.Tuple{``0,``1}},System.Collections.Generic.IEnumerable{System.Tuple{``0,``1}})">
<summary>
 Align two unordered sequences of `Key * Address` pairs and produce a collection
 that contains three-element tuples consisting of keys, optional address in the
 first sequence &amp; optional address in the second sequence. (See also `alignWithOrdering`)
</summary>
</member>
<member name="M:FSharp.DataFrame.Internal.Seq.alignWithOrdering``2(System.Collections.Generic.IEnumerable{System.Tuple{``0,``1}},System.Collections.Generic.IEnumerable{System.Tuple{``0,``1}},System.Collections.Generic.IComparer{``0})">
<summary>
 Align two ordered sequences of `Key * Address` pairs and produce a 
 collection that contains three-element tuples consisting of: 

   * ordered keys (from one or the ohter sequence)
   * optional address of the key in the first sequence
   * optional address of the key in the second sequence

</summary>
</member>
<member name="M:FSharp.DataFrame.Internal.Seq.tryFirstAndLast``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
 Returns the first and the last element from a sequence or &apos;None&apos; if the sequence is empty
</summary>
</member>
<member name="M:FSharp.DataFrame.Internal.Seq.isSorted``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IComparer{``0})">
<summary>
 Returns true if the specified sequence is sorted.
</summary>
</member>
<member name="M:FSharp.DataFrame.Internal.Seq.chunkedWithBounds``1(System.Int32,FSharp.DataFrame.Boundary,System.Collections.Generic.IEnumerable{``0})">
<summary>
 Similar to `Seq.windowedWithBounds`, but generates non-overlapping chunks
 rather than floating windows. See that function for detailed documentation.
 The function may iterate over the sequence repeatedly.
</summary>
</member>
<member name="M:FSharp.DataFrame.Internal.Seq.windowedWithBounds``1(System.Int32,FSharp.DataFrame.Boundary,System.Collections.Generic.IEnumerable{``0})">
<summary>
 A version of `Seq.windowed` that allows specifying more complex boundary
 behaviour. The `boundary` argument can specify one of the following options:
 
  * `Boundary.Skip` - only full windows are returned (like `Seq.windowed`)
  * `Boundary.AtBeginning` - incomplete windows (smaller than the required
    size) are returned at the beginning.
  * `Boundary.AtEnding` - incomplete windows are returned at the end.

 The result is a sequence of `DataSegnebt&lt;T&gt;` values, which makes it 
 easy to distinguish between complete and incomplete windows.
</summary>
</member>
<member name="M:FSharp.DataFrame.Internal.Seq.chunkedUsing``1(System.Collections.Generic.Comparer{``0},FSharp.DataFrame.Direction,System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
<summary>
 Generate non-overlapping chunks from the input sequence. Chunks are aligned
 to the specified keys. The `dir` parameter specifies the direction. If it is
 `Direction.Forward` than the key is the first element of a chunk; for 
 `Direction.Backward`, the key is the last element (note that this does not hold
 at the boundaries)
</summary>
</member>
<member name="M:FSharp.DataFrame.Internal.Seq.chunkedWhile``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean}},System.Collections.Generic.IEnumerable{``0})">
<summary>
 Generate non-verlapping chunks from the input sequence. A chunk is started 
 at the beginning and then immediately after the end of the previous chunk.
 To find the end of the chunk, the function calls the provided argument `f` 
 with the first and the last elements of the chunk as arguments. A chunk 
 ends when `f` returns `false`.
</summary>
</member>
<member name="M:FSharp.DataFrame.Internal.Seq.windowedWhile``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean}},System.Collections.Generic.IEnumerable{``0})">
<summary>
 Generate floating windows from the input sequence. New floating window is 
 started for each element. To find the end of the window, the function calls
 the provided argument `f` with the first and the last elements of the window
 as arguments. A window ends when `f` returns `false`.
</summary>
</member>
<member name="M:FSharp.DataFrame.Internal.Seq.startAndEnd``1(System.Int32,System.Int32,System.Collections.Generic.IEnumerable{``0})">
<summary>
 Given a sequence, returns `startCount` number of elements at the beginning 
 of the sequence (wrapped in `Choice1Of3`) followed by one `Choice2Of2()` value
 and then followed by `endCount` number of elements at the end of the sequence
 wrapped in `Choice3Of3`. If the input is shorter than `startCount + endCount`,
 then all values are returned and wrapped in `Choice1Of3`.
</summary>
</member>
<member name="M:FSharp.DataFrame.Internal.Seq.getEnumerator``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
 Calls the `GetEnumerator` method. Simple function to guide type inference.
</summary>
</member>
<member name="M:FSharp.DataFrame.Internal.Seq.lastFew``1(System.Int32,System.Collections.Generic.IEnumerable{``0})">
<summary>
 Returns the specified number of elements from the end of the sequence
 Note that this needs to store the specified number of elements in memory
 and it needs to iterate over the entire sequence.
</summary>
</member>
<member name="M:FSharp.DataFrame.Internal.Seq.headOrNone``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
 If the input is non empty, returns `Some(head)` where `head` is 
 the first value. Otherwise, returns `None`.
</summary>
</member>
<member name="M:FSharp.DataFrame.Internal.Seq.structuralHash``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
 Calculate hash code of a sequence, based on the values
</summary>
</member>
<member name="M:FSharp.DataFrame.Internal.Seq.structuralEquals``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
<summary>
 Comapre two sequences using the `Equals` method. Returns true
 when all their elements are equal and they have the same size.
</summary>
</member>
<member name="T:FSharp.DataFrame.Internal.Seq">
<summary>
 This module contains additional functions for working with sequences. 
 `FSharp.DataFrame.Internals` is opened, it extends the standard `Seq` module.
</summary>
</member>
<member name="M:FSharp.DataFrame.Internal.Array.binarySearchNearestSmaller``1(``0,System.Collections.Generic.IComparer{``0},``0[])">
<summary>
 Returns the index of &apos;key&apos; or the index of immediately preceeding value.
 If the specified key is smaller than all keys in the array, None is returned.
</summary>
</member>
<member name="M:FSharp.DataFrame.Internal.Array.binarySearchNearestGreater``1(``0,System.Collections.Generic.IComparer{``0},``0[])">
<summary>
 Returns the index of &apos;key&apos; or the index of immediately following value.
 If the specified key is greater than all keys in the array, None is returned.
</summary>
</member>
<member name="">

</member>
<member name="M:FSharp.DataFrame.Internal.Array.dropRange``1(System.Int32,System.Int32,``0[])">
<summary>
 Drop a specified range from a given array. The operation is inclusive on
 both sides. Given [ 1; 2; 3; 4 ] and indices (1, 2), the result is [ 1; 4 ]
</summary>
</member>
<member name="T:FSharp.DataFrame.Internal.Array">
<summary>
 This module contains additional functions for working with arrays. 
 `FSharp.DataFrame.Internals` is opened, it extends the standard `Array` module.
</summary>
</member>
<member name="M:FSharp.DataFrame.Internal.IReadOnlyList.lengthOptional``1(System.Collections.Generic.IReadOnlyList{FSharp.DataFrame.OptionalValue{``0}})">
<summary>
 Count elements of the IReadOnlyList that are not missing
</summary>
</member>
<member name="M:FSharp.DataFrame.Internal.IReadOnlyList.averageOptional``2(System.Collections.Generic.IReadOnlyList{FSharp.DataFrame.OptionalValue{``0}})">
<summary>
 Average elements of the IReadOnlyList, skipping over missing values
</summary>
</member>
<member name="M:FSharp.DataFrame.Internal.IReadOnlyList.reduceOptional``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,``0}},System.Collections.Generic.IReadOnlyList{FSharp.DataFrame.OptionalValue{``0}})">
<summary>
 Reduce elements of the IReadOnlyList, skipping over missing values
</summary>
</member>
<member name="M:FSharp.DataFrame.Internal.IReadOnlyList.sumOptional``2(System.Collections.Generic.IReadOnlyList{FSharp.DataFrame.OptionalValue{``0}})">
<summary>
 Sum elements of the IReadOnlyList, skipping over missing values
</summary>
</member>
<member name="M:FSharp.DataFrame.Internal.IReadOnlyList.average``2(System.Collections.Generic.IReadOnlyList{``0})">
<summary>
 Average elements of the IReadOnlyList
</summary>
</member>
<member name="M:FSharp.DataFrame.Internal.IReadOnlyList.length``1(System.Collections.Generic.IReadOnlyList{``0})">
<summary>
 Count elements of the IReadOnlyList
</summary>
</member>
<member name="M:FSharp.DataFrame.Internal.IReadOnlyList.reduce``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,``0}},System.Collections.Generic.IReadOnlyList{``0})">
<summary>
 Reduce elements of the IReadOnlyList
</summary>
</member>
<member name="M:FSharp.DataFrame.Internal.IReadOnlyList.sum``2(System.Collections.Generic.IReadOnlyList{``0})">
<summary>
 Sum elements of the IReadOnlyList
</summary>
</member>
<member name="M:FSharp.DataFrame.Internal.IReadOnlyList.ofSeq``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
 Converts a lazy sequence to fully evaluated IReadOnlyList
</summary>
</member>
<member name="M:FSharp.DataFrame.Internal.IReadOnlyList.ofArray``1(``0[])">
<summary>
 Converts an array to IReadOnlyList. In F# 3.0, the language does not
 know that array implements IReadOnlyList, so this is just boxing/unboxing.
</summary>
</member>
<member name="T:FSharp.DataFrame.Internal.IReadOnlyList">
<summary>
 Provides helper functions for working with `IReadOnlyList&lt;T&gt;` similar to those 
 in the `Array` module. Most importantly, F# 3.0 does not know that array implements
 `IReadOnlyList&lt;T&gt;`, so the `ofArray` function performs boxing &amp; unboxing to convert.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharp.DataFrame.Internal.MissingValues">
<summary>
 Utility functions for identifying missing values. The `isNA` function 
 can be used to test whether a value represents a missing value - this includes
 the `null` value, `Nullable&lt;T&gt;` value with `HasValue = false` and 
 `Single.NaN` as well as `Double.NaN`.

 The functions in this module are not intended to be called directly.
</summary>
</member>
<member name="">

</member>
<member name="M:FSharp.DataFrame.Keys.SimpleLookup`1.FSharp-DataFrame-ICustomLookup`1-Matches(`0)">
<summary>
 Dynamically tests whether this pattern matches with another key. 
 For example, `[|None, Some 1|]` matches `(42, 1)`, but if the second 
 values differed, then they would not match.
</summary>
</member>
<member name="">

</member>
<member name="T:FSharp.DataFrame.Keys.SimpleLookup`1">
<summary>
 Implements a simple lookup that matches any multi-level key against a specified array of
 optional objects (that represent missing/set parts of a key)
</summary>
</member>
<member name="">

</member>
<member name="M:FSharp.DataFrame.Keys.CustomKey.Get(System.Object)">
<summary>
 Returns `ICustomKey` instance for the specified key. If the specified key implements
 `ICustomKey`, then it is just returned; if it is a tuple, we use special key for tuples
 otherwise, it must be a primitive key so we just return it
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharp.DataFrame.Keys.CustomKey">
<summary>
 Helper type that can be used to get `ICustomKey` for any object (including objects
 that actually implement the interface and tuples)
</summary>
</member>
<member name="P:FSharp.DataFrame.Keys.ICustomKey.Levels">
<summary>
 Returns the number of levels of a hierarchical key. For example, a tuple (1, 42) has 2 levels.
 This is used for pretty printing only.
</summary>
</member>
<member name="M:FSharp.DataFrame.Keys.ICustomKey.GetLevels">
<summary>
 Gets values of the key at all levels
</summary>
</member>
<member name="M:FSharp.DataFrame.Keys.ICustomKey.GetLevel(System.Int32)">
<summary>
 Gets a value at the specified level (the levels are indexed from 1). 
 This is used for pretty printing only. If `Levels=1` then this method is not
 called and the pretty printer invokes `ToString` on the whole object instead.
</summary>
</member>
<member name="T:FSharp.DataFrame.Keys.ICustomKey">
<summary>
 Represents a special hierarchical key. This is mainly used in pretty printing (where we want to 
 get parts of the keys based on levels. `CustomKey.Get` provides a way of getting `ICustomKey`.
</summary>
</member>
<member name="M:FSharp.DataFrame.MultiKeyExtensions.LookupAnyOf4``5(Microsoft.FSharp.Core.FSharpOption{``0},Microsoft.FSharp.Core.FSharpOption{``1},Microsoft.FSharp.Core.FSharpOption{``2},Microsoft.FSharp.Core.FSharpOption{``3})">
<summary>
 Creates an arbitrary lookup key that allows matching on elements
 of a four-level hierarchical index. Specify `None` to ignore a level
 or `Some k` to require match on a given level.
</summary>
</member>
<member name="M:FSharp.DataFrame.MultiKeyExtensions.Lookup4Of4``2(``0)">
<summary>
 Creates a hierarchical key lookup that allows matching on the 
 fourth element of a four-level hierarchical key.
</summary>
</member>
<member name="M:FSharp.DataFrame.MultiKeyExtensions.Lookup3Of4``2(``0)">
<summary>
 Creates a hierarchical key lookup that allows matching on the 
 third element of a four-level hierarchical key.
</summary>
</member>
<member name="M:FSharp.DataFrame.MultiKeyExtensions.Lookup2Of4``2(``0)">
<summary>
 Creates a hierarchical key lookup that allows matching on the 
 second element of a four-level hierarchical key.
</summary>
</member>
<member name="M:FSharp.DataFrame.MultiKeyExtensions.Lookup1Of4``2(``0)">
<summary>
 Creates a hierarchical key lookup that allows matching on the 
 first element of a four-level hierarchical key.
</summary>
</member>
<member name="M:FSharp.DataFrame.MultiKeyExtensions.LookupAnyOf3``4(Microsoft.FSharp.Core.FSharpOption{``0},Microsoft.FSharp.Core.FSharpOption{``1},Microsoft.FSharp.Core.FSharpOption{``2})">
<summary>
 Creates an arbitrary lookup key that allows matching on elements
 of a three-level hierarchical index. Specify `None` to ignore a level
 or `Some k` to require match on a given level.
</summary>
</member>
<member name="M:FSharp.DataFrame.MultiKeyExtensions.Lookup3Of3``2(``0)">
<summary>
 Creates a hierarchical key lookup that allows matching on the 
 third element of a three-level hierarchical key.
</summary>
</member>
<member name="M:FSharp.DataFrame.MultiKeyExtensions.Lookup2Of3``2(``0)">
<summary>
 Creates a hierarchical key lookup that allows matching on the 
 second element of a three-level hierarchical key.
</summary>
</member>
<member name="M:FSharp.DataFrame.MultiKeyExtensions.Lookup1Of3``2(``0)">
<summary>
 Creates a hierarchical key lookup that allows matching on the 
 first element of a three-level hierarchical key.
</summary>
</member>
<member name="M:FSharp.DataFrame.MultiKeyExtensions.LookupAnyOf2``3(Microsoft.FSharp.Core.FSharpOption{``0},Microsoft.FSharp.Core.FSharpOption{``1})">
<summary>
 Creates an arbitrary lookup key that allows matching on elements
 of a two-level hierarchical index. Specify `None` to ignore a level
 or `Some k` to require match on a given level.
</summary>
</member>
<member name="M:FSharp.DataFrame.MultiKeyExtensions.Lookup2Of2``2(``0)">
<summary>
 Creates a hierarchical key lookup that allows matching on the 
 second element of a two-level hierarchical key.
</summary>
</member>
<member name="M:FSharp.DataFrame.MultiKeyExtensions.Lookup1Of2``2(``0)">
<summary>
 Creates a hierarchical key lookup that allows matching on the 
 first element of a two-level hierarchical key.
</summary>
</member>
<member name="T:FSharp.DataFrame.MultiKeyExtensions">
<summary>
 F#-friendly functions for creating multi-level keys and lookups
</summary>
</member>
<member name="M:FSharp.DataFrame.OptionalValueModule.|Missing|Present|``1(FSharp.DataFrame.OptionalValue{``0})">
<summary>
 Complete active pattern that can be used to pattern match on `OptionalValue&lt;T&gt;`.
 For example:

     let optVal = OptionalValue(42)
     match optVal with
     | OptionalValue.Missing -&gt; printfn &quot;Empty&quot;
     | OptionalValue.Present(v) -&gt; printfn &quot;Contains %d&quot; v

</summary>
</member>
<member name="M:FSharp.DataFrame.OptionalValueModule.ofOption``1(Microsoft.FSharp.Core.FSharpOption{``0})">
<summary>
 Turns a standard F# `option&lt;T&gt;` value into a corresponding `OptionalValue&lt;T&gt;`
</summary>
</member>
<member name="M:FSharp.DataFrame.OptionalValueModule.asOption``1(FSharp.DataFrame.OptionalValue{``0})">
<summary>
 Turns the `OptionalValue&lt;T&gt;` into a corresponding standard F# `option&lt;T&gt;` value
</summary>
</member>
<member name="M:FSharp.DataFrame.OptionalValueModule.OfNullable``1(System.Nullable{``0})">
<summary>
 Creates `OptionalValue&lt;T&gt;` from a .NET `Nullable&lt;T&gt;` type.
</summary>
</member>
<member name="M:FSharp.DataFrame.OptionalValueModule.OfTuple``1(System.Boolean,``0)">
<summary>
 Creates `OptionalValue&lt;T&gt;` from a tuple of type `bool * &apos;T`. This function
 can be used with .NET methods that use `out` arguments. For example:

     Int32.TryParse(&quot;42&quot;) |&gt; OptionalValue.ofTuple

</summary>
</member>
<member name="M:FSharp.DataFrame.OptionalValueModule.Map``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},FSharp.DataFrame.OptionalValue{``0})">
<summary>
 If the `OptionalValue&lt;T&gt;` does not contain a value, then returns a new 
 `OptionalValue&lt;R&gt;.Empty`. Otherwise, returns the result `OptionalValue&lt;R&gt;`
 containing the result of applying the function `f` to the value contained 
 in the provided optional value.
</summary>
</member>
<member name="M:FSharp.DataFrame.OptionalValueModule.Bind``2(Microsoft.FSharp.Core.FSharpFunc{``0,FSharp.DataFrame.OptionalValue{``1}},FSharp.DataFrame.OptionalValue{``0})">
<summary>
 If the `OptionalValue&lt;T&gt;` does not contain a value, then returns a new 
 `OptionalValue&lt;R&gt;.Empty`. Otherwise, returns the result of applying the 
 function `f` to the value contained in the provided optional value.
</summary>
</member>
<member name="T:FSharp.DataFrame.OptionalValueModule">
<summary>
 Provides various helper functions for using the `OptionalValue&lt;T&gt;` type from F#
 (The functions are similar to those in the standard `Option` module).
</summary>
</member>
<member name="M:FSharp.DataFrame.Pair.flatten4``4(``0,System.Tuple{``1,System.Tuple{``2,``3}})">
<summary>
 Flatten a two-level nested tuple into a flat tuple of 4 elements
</summary>
</member>
<member name="M:FSharp.DataFrame.Pair.flatten3``3(``0,System.Tuple{``1,``2})">
<summary>
 Flatten a two-level nested tuple into a flat tuple of 3 elements
</summary>
</member>
<member name="M:FSharp.DataFrame.Pair.get4Of4``4(``0,``1,``2,``3)">
<summary>
 Returns the fourth value of a four-level hierarchical tuple
</summary>
</member>
<member name="M:FSharp.DataFrame.Pair.get3Of4``4(``0,``1,``2,``3)">
<summary>
 Returns the third value of a four-level hierarchical tuple
</summary>
</member>
<member name="M:FSharp.DataFrame.Pair.get2Of4``4(``0,``1,``2,``3)">
<summary>
 Returns the second value of a four-level hierarchical tuple
</summary>
</member>
<member name="M:FSharp.DataFrame.Pair.get1Of4``4(``0,``1,``2,``3)">
<summary>
 Returns the first value of a four-level hierarchical tuple
</summary>
</member>
<member name="M:FSharp.DataFrame.Pair.get1And3Of3``3(``0,``1,``2)">
<summary>
 Returns the first and the third value of a three-level hierarchical tuple
</summary>
</member>
<member name="M:FSharp.DataFrame.Pair.get2And3Of3``3(``0,``1,``2)">
<summary>
 Returns the second and the third value of a three-level hierarchical tuple
</summary>
</member>
<member name="M:FSharp.DataFrame.Pair.get1And2Of3``3(``0,``1,``2)">
<summary>
 Returns the first and the second value of a three-level hierarchical tuple
</summary>
</member>
<member name="M:FSharp.DataFrame.Pair.get3Of3``3(``0,``1,``2)">
<summary>
 Returns the third value of a three-level hierarchical tuple
</summary>
</member>
<member name="M:FSharp.DataFrame.Pair.get2Of3``3(``0,``1,``2)">
<summary>
 Returns the second value of a three-level hierarchical tuple
</summary>
</member>
<member name="M:FSharp.DataFrame.Pair.get1Of3``3(``0,``1,``2)">
<summary>
 Returns the first value of a three-level hierarchical tuple
</summary>
</member>
<member name="M:FSharp.DataFrame.Pair.get2Of2``2(``0,``1)">
<summary>
 Returns the second value of a two-level hierarchical tuple
</summary>
</member>
<member name="M:FSharp.DataFrame.Pair.get1Of2``2(``0,``1)">
<summary>
 Returns the first value of a two-level hierarchical tuple
</summary>
</member>
<member name="T:FSharp.DataFrame.Pair">
<summary>
 Module with helper functions for extracting values from hierarchical tuples
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharp.DataFrame.Reflection">

</member>
<member name="M:FSharp.DataFrame.SeriesModule.lookupTimeAt``2(``0,System.TimeSpan,FSharp.DataFrame.Direction,FSharp.DataFrame.Lookup,FSharp.DataFrame.Series{``0,``1})">
<summary>
 Finds values at, or near, the specified times in a given series. The operation generates
 keys starting at the specified `start` time, using the specified `interval`
 and then finds values close to such keys using the specified `lookup` and `dir`.
 
 ## Parameters
  - `series` - An input series to be resampled
  - `start` - The initial time to be used for sampling
  - `interval` - The interval between the individual samples 
  - `dir` - Specifies how the keys should be generated. `Direction.Forward` means that the 
    key is the smallest value of each chunk (and so first key of the series is returned and 
    the last is not, unless it matches exactly _start + k*interval_); `Direction.Backward`
    means that the first key is skipped and sample is generated at, or just before the end 
    of interval and at the end of the series.
  - `lookup` - Specifies how the lookup based on keys is performed. `Exact` means that the
    values at exact keys will be returned; `NearestGreater` returns the nearest greater key value
    (starting at the first key) and `NearestSmaller` returns the nearest smaller key value
    (starting at most `interval` after the end of the series)
 
 ## Remarks
 This operation is only supported on ordered series. The method throws
 `InvalidOperationException` when the series is not ordered. 
 
 [category:Lookup, resampling and scaling]
</summary>
</member>
<member name="M:FSharp.DataFrame.SeriesModule.lookupTime``2(System.TimeSpan,FSharp.DataFrame.Direction,FSharp.DataFrame.Lookup,FSharp.DataFrame.Series{``0,``1})">
<summary>
 Finds values at, or near, the specified times in a given series. The operation generates
 keys starting from the smallest key of the original series, using the specified `interval`
 and then finds values close to such keys using the specified `lookup` and `dir`.
 
 ## Parameters
  - `series` - An input series to be resampled
  - `interval` - The interval between the individual samples 
  - `dir` - Specifies how the keys should be generated. `Direction.Forward` means that the 
    key is the smallest value of each chunk (and so first key of the series is returned and 
    the last is not, unless it matches exactly _start + k*interval_); `Direction.Backward`
    means that the first key is skipped and sample is generated at, or just before the end 
    of interval and at the end of the series.
  - `lookup` - Specifies how the lookup based on keys is performed. `Exact` means that the
    values at exact keys will be returned; `NearestGreater` returns the nearest greater key value
    (starting at the first key) and `NearestSmaller` returns the nearest smaller key value
    (starting at most `interval` after the end of the series)
 
 ## Remarks
 This operation is only supported on ordered series. The method throws
 `InvalidOperationException` when the series is not ordered. 
 
 [category:Lookup, resampling and scaling]
</summary>
</member>
<member name="M:FSharp.DataFrame.SeriesModule.sampleTimeAt``2(``0,System.TimeSpan,FSharp.DataFrame.Direction,FSharp.DataFrame.Series{``0,``1})">
<summary>
 Performs sampling by time and returns chunks obtained by time-sampling as a nested  
 series. The operation generates keys starting at the given `start` time, using the 
 specified `interval` and then obtains chunks based on these
 keys in a fashion similar to the `Series.resample` function.

 ## Parameters
  - `series` - An input series to be resampled
  - `start` - The initial time to be used for sampling
  - `interval` - The interval between the individual samples 
  - `dir` - If this parameter is `Direction.Forward`, then each key is
    used as the smallest key in a chunk; for `Direction.Backward`, the keys are
    used as the greatest keys in a chunk.

 ## Remarks
 This operation is only supported on ordered series. The method throws
 `InvalidOperationException` when the series is not ordered. 
 
 [category:Lookup, resampling and scaling]
</summary>
</member>
<member name="M:FSharp.DataFrame.SeriesModule.sampleTime``2(System.TimeSpan,FSharp.DataFrame.Direction,FSharp.DataFrame.Series{``0,``1})">
<summary>
 Performs sampling by time and returns chunks obtained by time-sampling as a nested  
 series. The operation generates keys starting at the first key in the source series,
 using the specified `interval` and then obtains chunks based on these
 keys in a fashion similar to the `Series.resample` function.

 ## Parameters
  - `series` - An input series to be resampled
  - `interval` - The interval between the individual samples 
  - `dir` - If this parameter is `Direction.Forward`, then each key is
    used as the smallest key in a chunk; for `Direction.Backward`, the keys are
    used as the greatest keys in a chunk.

 ## Remarks
 This operation is only supported on ordered series. The method throws
 `InvalidOperationException` when the series is not ordered. 
 
 [category:Lookup, resampling and scaling]
</summary>
</member>
<member name="M:FSharp.DataFrame.SeriesModule.sampleTimeAtInto``3(``0,System.TimeSpan,FSharp.DataFrame.Direction,Microsoft.FSharp.Core.FSharpFunc{FSharp.DataFrame.Series{``0,``1},``2},FSharp.DataFrame.Series{``0,``1})">
<summary>
 Performs sampling by time and aggregates chunks obtained by time-sampling into a single
 value using a specified function. The operation generates keys starting at the given
 `start` time, using the specified `interval` and then obtains chunks based on these
 keys in a fashion similar to the `Series.resample` function.

 ## Parameters
  - `series` - An input series to be resampled
  - `start` - The initial time to be used for sampling
  - `interval` - The interval between the individual samples 
  - `dir` - If this parameter is `Direction.Forward`, then each key is
    used as the smallest key in a chunk; for `Direction.Backward`, the keys are
    used as the greatest keys in a chunk.
  - `f` - A function that is called to aggregate each chunk into a single value.

 ## Remarks
 This operation is only supported on ordered series. The method throws
 `InvalidOperationException` when the series is not ordered. 
 
 [category:Lookup, resampling and scaling]
</summary>
</member>
<member name="M:FSharp.DataFrame.SeriesModule.sampleTimeInto``3(System.TimeSpan,FSharp.DataFrame.Direction,Microsoft.FSharp.Core.FSharpFunc{FSharp.DataFrame.Series{``0,``1},``2},FSharp.DataFrame.Series{``0,``1})">
<summary>
 Performs sampling by time and aggregates chunks obtained by time-sampling into a single
 value using a specified function. The operation generates keys starting at the first
 key in the source series, using the specified `interval` and then obtains chunks based on 
 these keys in a fashion similar to the `Series.resample` function.

 ## Parameters
  - `series` - An input series to be resampled
  - `interval` - The interval between the individual samples 
  - `dir` - If this parameter is `Direction.Forward`, then each key is
    used as the smallest key in a chunk; for `Direction.Backward`, the keys are
    used as the greatest keys in a chunk.
  - `f` - A function that is called to aggregate each chunk into a single value.

 ## Remarks
 This operation is only supported on ordered series. The method throws
 `InvalidOperationException` when the series is not ordered. 
 
 [category:Lookup, resampling and scaling]
</summary>
</member>
<member name="M:FSharp.DataFrame.SeriesModule.resampleUniform``3(FSharp.DataFrame.Lookup,Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``1,``1},FSharp.DataFrame.Series{``0,``2})">
<summary>
 Resample the series based on equivalence class on the keys and also generate values 
 for all keys of the target space that are between the minimal and maximal key of the
 specified series (e.g. generate value for all days in the range covered by the series).
 A specified function `keyProj` is used to project keys to another space and `nextKey`
 is used to generate all keys in the range. Then return the chunks as nested series.

 When there are no values for a (generated) key, then the function behaves according to
 `fillMode`. It can look at the greatest value of previous chunk or smallest value of the
 next chunk, or it produces an empty series.

 ## Parameters
  - `series` - An input series to be resampled
  - `fillMode` - When set to `Lookup.NearestSmaller` or `Lookup.NearestGreater`, 
     the function searches for a nearest available observation in an neighboring chunk.
     Otherwise, the function `f` is called with an empty series as an argument.
  - `keyProj` - A function that transforms keys from original space to a new 
    space (which is then used for grouping based on equivalence)
  - `nextKey` - A function that gets the next key in the transformed space
    
 ## Remarks
 This operation is only supported on ordered series. The method throws
 `InvalidOperationException` when the series is not ordered. 

 [category:Lookup, resampling and scaling]
</summary>
</member>
<member name="M:FSharp.DataFrame.SeriesModule.resampleUniformInto``4(FSharp.DataFrame.Lookup,Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``1,``1},Microsoft.FSharp.Core.FSharpFunc{FSharp.DataFrame.Series{``0,``2},``3},FSharp.DataFrame.Series{``0,``2})">
<summary>
 Resample the series based on equivalence class on the keys and also generate values 
 for all keys of the target space that are between the minimal and maximal key of the
 specified series (e.g. generate value for all days in the range covered by the series).
 A specified function `keyProj` is used to project keys to another space and `nextKey`
 is used to generate all keys in the range. The chunk is then aggregated using `f`.

 When there are no values for a (generated) key, then the function behaves according to
 `fillMode`. It can look at the greatest value of previous chunk or smallest value of the
 next chunk, or it produces an empty series.

 ## Parameters
  - `series` - An input series to be resampled
  - `fillMode` - When set to `Lookup.NearestSmaller` or `Lookup.NearestGreater`, 
     the function searches for a nearest available observation in an neighboring chunk.
     Otherwise, the function `f` is called with an empty series as an argument.
  - `keyProj` - A function that transforms keys from original space to a new 
    space (which is then used for grouping based on equivalence)
  - `nextKey` - A function that gets the next key in the transformed space
  - `f` - A function that is used to collapse a generated chunk into a 
    single value. The function may be called on empty series when `fillMode` is
    `Lookup.Exact`.
    
 ## Remarks
 This operation is only supported on ordered series. The method throws
 `InvalidOperationException` when the series is not ordered. 

 [category:Lookup, resampling and scaling]
</summary>
</member>
<member name="M:FSharp.DataFrame.SeriesModule.resampleEquiv``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},FSharp.DataFrame.Series{``0,``2})">
<summary>
 Resample the series based on equivalence class on the keys. A specified function
 `keyProj` is used to project keys to another space and the observations for which the 
 projected keys are equivalent are grouped into chunks. The chunks are then returned
 as nested series.

 ## Parameters
  - `series` - An input series to be resampled
  - `keyProj` - A function that transforms keys from original space to a new 
    space (which is then used for grouping based on equivalence)

 ## Remarks
 This function is similar to `Series.chunkBy`, with the exception that it transforms
 keys to a new space.

 This operation is only supported on ordered series. The method throws
 `InvalidOperationException` when the series is not ordered. For unordered
 series, similar functionality can be implemented using `Series.groupBy`.

 [category:Lookup, resampling and scaling]
</summary>
</member>
<member name="M:FSharp.DataFrame.SeriesModule.resampleEquivInto``4(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{FSharp.DataFrame.Series{``0,``2},``3},FSharp.DataFrame.Series{``0,``2})">
<summary>
 Resample the series based on equivalence class on the keys. A specified function
 `keyProj` is used to project keys to another space and the observations for which the 
 projected keys are equivalent are grouped into chunks. The chunks are then transformed
 to values using the provided function `f`.

 ## Parameters
  - `series` - An input series to be resampled
  - `keyProj` - A function that transforms keys from original space to a new 
    space (which is then used for grouping based on equivalence)
  - `f` - A function that is used to collapse a generated chunk into a 
    single value. 

 ## Remarks
 This function is similar to `Series.chunkBy`, with the exception that it transforms
 keys to a new space.

 This operation is only supported on ordered series. The method throws
 `InvalidOperationException` when the series is not ordered. For unordered
 series, similar functionality can be implemented using `Series.groupBy`.

 [category:Lookup, resampling and scaling]
</summary>
</member>
<member name="M:FSharp.DataFrame.SeriesModule.resample``2(System.Collections.Generic.IEnumerable{``0},FSharp.DataFrame.Direction,FSharp.DataFrame.Series{``0,``1})">
<summary>
 Resample the series based on a provided collection of keys. The values of the series
 are aggregated into chunks based on the specified keys. Depending on `direction`, the 
 specified key is either used as the smallest or as the greatest key of the chunk (with
 the exception of boundaries that are added to the first/last chunk).
 Such chunks are then returned as nested series.

 ## Parameters
  - `series` - An input series to be resampled
  - `keys` - A collection of keys to be used for resampling of the series
  - `dir` - If this parameter is `Direction.Forward`, then each key is
    used as the smallest key in a chunk; for `Direction.Backward`, the keys are
    used as the greatest keys in a chunk.

 ## Remarks
 This operation is only supported on ordered series. The method throws
 `InvalidOperationException` when the series is not ordered.

 [category:Lookup, resampling and scaling]
</summary>
</member>
<member name="M:FSharp.DataFrame.SeriesModule.resampleInto``3(System.Collections.Generic.IEnumerable{``0},FSharp.DataFrame.Direction,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{FSharp.DataFrame.Series{``0,``1},``2}},FSharp.DataFrame.Series{``0,``1})">
<summary>
 Resample the series based on a provided collection of keys. The values of the series
 are aggregated into chunks based on the specified keys. Depending on `direction`, the 
 specified key is either used as the smallest or as the greatest key of the chunk (with
 the exception of boundaries that are added to the first/last chunk).
 Such chunks are then aggregated using the provided function `f`.

 ## Parameters
  - `series` - An input series to be resampled
  - `keys` - A collection of keys to be used for resampling of the series
  - `dir` - If this parameter is `Direction.Forward`, then each key is
    used as the smallest key in a chunk; for `Direction.Backward`, the keys are
    used as the greatest keys in a chunk.
  - `f` - A function that is used to collapse a generated chunk into a 
    single value. Note that this function may be called with empty series.

 ## Remarks
 This operation is only supported on ordered series. The method throws
 `InvalidOperationException` when the series is not ordered.

 [category:Lookup, resampling and scaling]
</summary>
</member>
<member name="M:FSharp.DataFrame.SeriesModule.fillMissing``2(FSharp.DataFrame.Direction,FSharp.DataFrame.Series{``0,``1})">
<summary>
 Fill missing values in the series with the nearest available value
 (using the specified direction). Note that the series may still contain
 missing values after call to this function. This operation can only be
 used on ordered series.

 ## Parameters
  - `series` - An input series that is to be filled
  - `direction` - Specifies the direction used when searching for 
    the nearest available value. `Backward` means that we want to
    look for the first value with a smaller key while `Forward` searches
    for the nearest greater key.

 ## Example

     let sample = Series.ofValues [ Double.NaN; 1.0; Double.NaN; 3.0 ]

     // Returns a series consisting of [1; 1; 3; 3]
     sample |&gt; Series.fillMissing Direction.Backward

     // Returns a series consisting of [&lt;missing&gt;; 1; 1; 3]
     sample |&gt; Series.fillMissing Direction.Forward 

 [category:Missing values]
</summary>
</member>
<member name="M:FSharp.DataFrame.SeriesModule.fillMissingWith``2(``0,FSharp.DataFrame.Series{``1,``0})">
<summary>
 Fill missing values in the series with a constant value.

 ## Parameters
  - `series` - An input series that is to be filled
  - `value` - A constant value that is used to fill all missing values

 [category:Missing values]
</summary>
</member>
<member name="M:FSharp.DataFrame.SeriesModule.fillMissingUsing``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},FSharp.DataFrame.Series{``0,``1})">
<summary>
 Fill missing values in the series using the specified function.
 The specified function is called with all keys for which the series
 does not contain value and the result of the call is used in place 
 of the missing value. 

 ## Parameters
  - `series` - An input series that is to be filled
  - `f` - A function that takes key `K` and generates a value to be
    used in a place where the original series contains a missing value.

 ## Remarks
 This function can be used to implement more complex interpolation.
 For example see [handling missing values in the tutorial](../features.html#missing)

 [category:Missing values]
</summary>
</member>
<member name="M:FSharp.DataFrame.SeriesModule.dropMissing``2(FSharp.DataFrame.Series{``0,``1})">
<summary>
 Drop missing values from the specified series. The returned series contains 
 only those keys for which there is a value available in the original one.

 ## Parameters
  - `series` - An input series to be filtered

 ## Example

     let s = series [ 1 =&gt; 1.0; 2 =&gt; Double.NaN ]
     s |&gt; Series.dropMissing 
     [fsi:val it : Series&lt;int,float&gt; = series [ 1 =&gt; 1]

 [category:Missing values]
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharp.DataFrame.SeriesModule.countKeys``2(FSharp.DataFrame.Series{``0,``1})">
<summary>
 Returns the total number of keys in the specified series. This returns
 the total length of the series, including keys for which there is no 
 value available.
</summary>
</member>
<member name="M:FSharp.DataFrame.SeriesModule.countValues``2(FSharp.DataFrame.Series{``0,``1})">
<summary>
 Returns the total number of values in the specified series. This excludes
 missing values or not available values (such as values created from `null`,
 `Double.NaN`, or those that are missing due to outer join etc.).
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharp.DataFrame.SeriesModule.aggregate``3(FSharp.DataFrame.Aggregation{``0},Microsoft.FSharp.Core.FSharpFunc{FSharp.DataFrame.DataSegment{FSharp.DataFrame.Series{``0,``1}},``2},FSharp.DataFrame.Series{``0,``1})">
<summary>
 Stuff
 [category:Windowing, chunking and grouping]
</summary>
</member>
<member name="M:FSharp.DataFrame.SeriesModule.diff``3(System.Int32,FSharp.DataFrame.Series{``0,``1})">
<summary>
 `result[k] = series[k] - series[k - offset]`
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharp.DataFrame.SeriesModule.get``2(``0,FSharp.DataFrame.Series{``0,``1})">
<summary>
 Get the value for the specified key.
 Uses exact lookup semantics for key lookup - use `lookupAll` for more options
</summary>
</member>
<member name="M:FSharp.DataFrame.SeriesModule.lookup``2(``0,FSharp.DataFrame.Lookup,FSharp.DataFrame.Series{``0,``1})">
<summary>
 Get the value for the specified key.
 Use the specified lookup semantics - for exact matching, use `get`
</summary>
</member>
<member name="M:FSharp.DataFrame.SeriesModule.getAll``2(System.Collections.Generic.IEnumerable{``0},FSharp.DataFrame.Series{``0,``1})">
<summary>
 Create a new series that contains values for all provided keys.
 Uses exact lookup semantics for key lookup - use `lookupAll` for more options
</summary>
</member>
<member name="M:FSharp.DataFrame.SeriesModule.lookupAll``2(System.Collections.Generic.IEnumerable{``0},FSharp.DataFrame.Lookup,FSharp.DataFrame.Series{``0,``1})">
<summary>
 Create a new series that contains values for all provided keys.
 Use the specified lookup semantics - for exact matching, use `getAll`
</summary>
</member>
<member name="M:FSharp.DataFrame.SeriesModule.observationsAll``2(FSharp.DataFrame.Series{``0,``1})">
<summary>
 Returns all keys from the sequence, together with the associated (optional) values. 
</summary>
</member>
<member name="M:FSharp.DataFrame.SeriesModule.observations``2(FSharp.DataFrame.Series{``0,``1})">
<summary>
 Return observations with available values. The operation skips over 
 all keys with missing values (such as values created from `null`,
 `Double.NaN`, or those that are missing due to outer join etc.).
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharp.DataFrame.SeriesModule.fastStatBy``4(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{System.Collections.Generic.IReadOnlyList{``2},``3},Microsoft.FSharp.Core.FSharpFunc{System.Collections.Generic.IReadOnlyList{FSharp.DataFrame.OptionalValue{``2}},``3},Microsoft.FSharp.Core.FSharpFunc{System.Collections.Generic.IEnumerable{``2},``3},FSharp.DataFrame.Series{``0,``2})">
<summary>
 [omit]
 Does stuff
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharp.DataFrame.SeriesModule.Implementation.lookupTimeInternal``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}},Microsoft.FSharp.Core.FSharpOption{``0},``1,FSharp.DataFrame.Direction,FSharp.DataFrame.Lookup,FSharp.DataFrame.Series{``0,``2})">
<summary>
 Given a specified starting time and time span, generates all keys that fit in the
 range of the series (and one additional, if `dir = Backward`) and then performs lookup
 for each key using the specified direction
</summary>
</member>
<member name="M:FSharp.DataFrame.SeriesModule.Implementation.sampleTimeIntoInternal``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}},Microsoft.FSharp.Core.FSharpOption{``0},``1,FSharp.DataFrame.Direction,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{FSharp.DataFrame.Series{``0,``2},``3}},FSharp.DataFrame.Series{``0,``2})">
<summary>
 Given a specified starting time and time span, generates all keys that fit in the
 range of the series (and one additional, if `dir = Backward`) and then performs
 sampling using `resampleInto`.
</summary>
</member>
<member name="">

</member>
<member name="T:FSharp.DataFrame.SeriesModule.Implementation">
<summary>
 [omit]
 Module that contains an implementation of sampling for `sampleTime` and 
 `sampleTimeInto`. For technical reasons (`inline`) this is public..
</summary>
</member>
<member name="T:FSharp.DataFrame.SeriesModule">
<summary>
 Series module comment..
 
 ## Example
 Not really

 ## Lookup, resampling and scaling
 More stuff here

 ## Windowing, chunking and grouping
 The functions with name starting with `windowed` take a series and generate floating 
 (overlapping) windows. The `chunk` functions 

</summary>
</member>
<member name="M:FSharp.DataFrame.VectorExtensions.IVector`1.get_DataSequence``1(FSharp.DataFrame.IVector{``0})">
<summary>
 Returns the data of the vector as a lazy sequence. (This preserves the 
 order of elements in the vector and so it also returns missing values.)
</summary>
</member>
<member name="T:FSharp.DataFrame.VectorExtensions">
<summary>
 Module with extensions for generic vector type. Given `vec` of type `IVector&lt;T&gt;`, 
 the extension property `vec.DataSequence` returns all data of the vector converted
 to the &quot;least common denominator&quot; data structure - `IEnumerable&lt;T&gt;`.
</summary>
</member>
<member name="P:FSharp.DataFrame.VectorHelpers.VectorValueTransform.RightIfAvailable">
<summary>
 A generic transformation that prefers the left value (if it is not missing)
</summary>
</member>
<member name="P:FSharp.DataFrame.VectorHelpers.VectorValueTransform.LeftOrRight">
<summary>
 A generic transformation that works when at most one value is defined
</summary>
</member>
<member name="P:FSharp.DataFrame.VectorHelpers.VectorValueTransform.LeftIfAvailable">
<summary>
 A generic transformation that prefers the left value (if it is not missing)
</summary>
</member>
<member name="M:FSharp.DataFrame.VectorHelpers.VectorValueTransform.CreateLifted``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,``0}})">
<summary>
 Creates a transformation that applies the specified function on `&apos;T` values 
</summary>
</member>
<member name="M:FSharp.DataFrame.VectorHelpers.VectorValueTransform.Create``1(Microsoft.FSharp.Core.FSharpFunc{FSharp.DataFrame.OptionalValue{``0},Microsoft.FSharp.Core.FSharpFunc{FSharp.DataFrame.OptionalValue{``0},FSharp.DataFrame.OptionalValue{``0}}})">
<summary>
 Creates a transformation that applies the specified function on `&apos;T` values 
</summary>
</member>
<member name="T:FSharp.DataFrame.VectorHelpers.VectorValueTransform">
<summary>
 A type that implements common vector value transformations and 
 a helper method for creating transformation on values of known types
</summary>
</member>
<member name="">

</member>
<member name="T:FSharp.DataFrame.VectorHelpers.VectorCallSite2`1">
<summary>
 Represents a generic function `\forall.&apos;T.(IVector&lt;&apos;T&gt; * IVector&lt;&apos;T&gt; -&gt; &apos;R)`. The function 
 can be generically invoked on a pair of `IVector` values using `createTwoVectorDispatcher`
</summary>
</member>
<member name="">

</member>
<member name="T:FSharp.DataFrame.VectorHelpers.VectorCallSite1`1">
<summary>
 Represents a generic function `\forall.&apos;T.(IVector&lt;&apos;T&gt; -&gt; &apos;R)`. The function can be 
 generically invoked on an argument of type `IVector` using `createVectorDispatcher`
</summary>
</member>
<member name="">

</member>
<member name="T:FSharp.DataFrame.VectorHelpers.ValueCallSite1`1">
<summary>
 Represents a generic function `\forall.&apos;T.(&apos;T -&gt; &apos;R)`. The function can be 
 generically invoked on an argument of type `obj` using `createValueDispatcher`
</summary>
</member>
<member name="M:FSharp.DataFrame.VectorHelpers.substitute(System.Int32,System.Int32)">
<summary>
 Substitute variable hole for another in a vector construction
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharp.DataFrame.VectorHelpers.createTwoVectorDispatcher``1(FSharp.DataFrame.VectorHelpers.VectorCallSite2{``0})">
<summary>
 Creates a function `IVector * IVector -&gt; &apos;R` that dynamically invokes to 
 a generic `Invoke` method of the provided `VectorCallSite2&lt;&apos;R&gt;`
</summary>
</member>
<member name="M:FSharp.DataFrame.VectorHelpers.createVectorDispatcher``1(FSharp.DataFrame.VectorHelpers.VectorCallSite1{``0})">
<summary>
 Creates a function `IVector -&gt; &apos;R` that dynamically invokes to 
 a generic `Invoke` method of the provided `VectorCallSite1&lt;&apos;R&gt;`
</summary>
</member>
<member name="M:FSharp.DataFrame.VectorHelpers.createValueDispatcher``1(FSharp.DataFrame.VectorHelpers.ValueCallSite1{``0})">
<summary>
 Creates a function `obj -&gt; &apos;R` that dynamically invokes to 
 a generic `Invoke` method of the provided `ValueCallSite1&lt;&apos;R&gt;`
</summary>
</member>
<member name="P:FSharp.DataFrame.VectorHelpers.stringCode">
<summary>
 Type code of the `string` type for efficient type equality test
</summary>
</member>
<member name="P:FSharp.DataFrame.VectorHelpers.intCode">
<summary>
 Type code of the `int` type for efficient type equality test
</summary>
</member>
<member name="P:FSharp.DataFrame.VectorHelpers.doubleCode">
<summary>
 Type code of the `float` type for efficient type equality test
</summary>
</member>
<member name="M:FSharp.DataFrame.VectorHelpers.delegatedVector``1(Microsoft.FSharp.Core.FSharpRef{FSharp.DataFrame.IVector{``0}})">
<summary>
 Create a new vector that delegates all functionality to a ref vector
</summary>
</member>
<member name="M:FSharp.DataFrame.VectorHelpers.prettyPrintVector``1(FSharp.DataFrame.IVector{``0})">
<summary>
 Pretty printer for vectors. This uses the &apos;Data&apos; property
</summary>
</member>
<member name="T:FSharp.DataFrame.VectorHelpers">
<summary>
 A module with various utilities for working with vectors. 
</summary>
</member>
<member name="M:FSharp.DataFrame.Vectors.IVectorBuilder.CreateMissing``1(FSharp.DataFrame.OptionalValue{``0}[])">
<summary>
 Create a vector from an array containing values that may be missing. 
 Even if a value is passed, it may be a missing value such as `Double.NaN`
 or `null`. The vector builder should hanlde this.
</summary>
</member>
<member name="M:FSharp.DataFrame.Vectors.IVectorBuilder.Create``1(``0[])">
<summary>
 Create a vector from an array containing values. The values may 
 still represent missing values and the vector should handle this.
 For example `Double.NaN` or `null` should be turned into a missing
 value in the returned vector.
</summary>
</member>
<member name="M:FSharp.DataFrame.Vectors.IVectorBuilder.Build``1(FSharp.DataFrame.Vectors.VectorConstruction,FSharp.DataFrame.IVector{``0}[])">
<summary>
 Apply a vector construction to a given vector. The second parameter
 is an array of arguments (&quot;variables&quot;) that may be referenced from the
 `VectorConstruction` using the `Return 0` construct.
</summary>
</member>
<member name="T:FSharp.DataFrame.Vectors.IVectorBuilder">
<summary>
 Represents an object that can construct vector values by processing 
 the &quot;mini-DSL&quot; representation `VectorConstruction`.
</summary>
</member>
<member name="M:FSharp.DataFrame.Vectors.IVectorValueTransform.GetFunction``1">
<summary>
 Returns a function that combines two values stored in vectors into a new vector value.
 Although generic, this function will only be called with the `T` set to the
 type of vector that is being built. Since `VectorConstruction` is not generic,
 the type cannot be statically propagated.
</summary>
</member>
<member name="T:FSharp.DataFrame.Vectors.IVectorValueTransform">
<summary>
 Represent a transformation that is applied when combining two vectors
 (because we are combining untyped `IVector` values, the transformation
 is also untyped)
</summary>
</member>
<member name="T:FSharp.DataFrame.Vectors.VectorConstruction.CustomCommand">
<summary>
 Apply a custom command to a vector - this can be used by special indices (e.g. index
 for a lazy vector) to provide a custom operations to be used. The first parameter
 is a list of sub-vectors to be combined (if as in e.g. `Append`) and the
 second argument is a function that will be called with evaluated vectors and is
 supposed to create the new vector.
</summary>
</member>
<member name="T:FSharp.DataFrame.Vectors.VectorConstruction.Combine">
<summary>
 Combine two aligned vectors. The `IVectorValueTransform` object
 specifies how to merge values (in case there is a value at a given address
 in both of the vectors).
</summary>
</member>
<member name="T:FSharp.DataFrame.Vectors.VectorConstruction.Append">
<summary>
 Append two vectors after each other
</summary>
</member>
<member name="T:FSharp.DataFrame.Vectors.VectorConstruction.GetRange">
<summary>
 Get the specified range of addresses from the vector and return it as a new vector
</summary>
</member>
<member name="T:FSharp.DataFrame.Vectors.VectorConstruction.DropRange">
<summary>
 Drop the specified range of addresses from the vector 
 and return a new vector that excludes the range
</summary>
</member>
<member name="T:FSharp.DataFrame.Vectors.VectorConstruction.Relocate">
<summary>
 Reorders elements of the vector. Carries a new required vector range and a list
 of relocations (each pair of addresses specifies that an element at a new address 
 should be filled with an element from an old address). THe addresses may be out of range!
</summary>
</member>
<member name="T:FSharp.DataFrame.Vectors.VectorConstruction.Empty">
<summary>
 Creates an empty vector of the requested type
</summary>
</member>
<member name="T:FSharp.DataFrame.Vectors.VectorConstruction.Return">
<summary>
 When constructing vectors, we get an array of vectors to be used as &quot;variables&quot;
 - this element represent getting one of the variables.
</summary>
</member>
<member name="T:FSharp.DataFrame.Vectors.VectorConstruction">
<summary>
 A &quot;mini-DSL&quot; that describes construction of a vector. Vector can be constructed
 from various range operations (relocate, drop, slicing, appending), by combination
 of two vectors or by taking a vector from a list of variables.

 Notably, vectors can only be constructed from other vectors of the same type 
 (the `Combine` operation requires this - even though that one could be made more general).
 This is an intentional choice to make the representation simpler.

 Logically, when we apply some index operation, we should get back a polymorphic vector
 construction (`\forall T. VectorConstruction&lt;T&gt;`) that can be applied to variuous 
 different vector types. That would mean adding some more types, so we just model vector
 construction as an untyped operation and the typing is resquired by the `Build` method
 of the vector builder.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharp.DataFrame.Vectors.VectorData`1">
<summary>
 Provides a way to get the data of an arbitrary vector. This is a concrete type used 
 by functions that operate on vectors (like `Series.sum`, etc.). The vector may choose
 to return the data as `IReadOnlyList` (with or without N/A values) which is more
 efficient to use or as a lazy sequence (slower, but more general).
</summary>
</member>
<member name="T:FSharp.DataFrame.Vectors.VectorHole">
<summary>
 Representes a &quot;variable&quot; in the mini-DSL below
</summary>
</member>
<member name="T:FSharp.DataFrame.Vectors.VectorRange">
<summary>
 Represents a range inside a vector
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharp.DataFrame.Vectors.ArrayVector.ArrayVector`1">
<summary>
 --------------------------------------------------------------------------------------
 Vector that stores data in an array. The data is stored using the
 `ArrayVectorData&lt;&apos;T&gt;` type (discriminated union)
</summary>
</member>
<member name="">

</member>
<member name="F:FSharp.DataFrame.Vectors.ArrayVector.FSharp.DataFrame.Vectors.ArrayVector.ArrayVectorBuilder.vectorBuilder">
<summary>
 Instance of the vector builder
</summary>
</member>
<member name="P:FSharp.DataFrame.Vectors.ArrayVector.ArrayVectorBuilder.Instance">
<summary>
 Provides a global access to an instance of the `ArrayVectorBuilder`
</summary>
</member>
<member name="M:FSharp.DataFrame.Vectors.ArrayVector.ArrayVectorBuilder.buildArrayVector``1(FSharp.DataFrame.Vectors.VectorConstruction,FSharp.DataFrame.IVector{``0}[])">
<summary>
 Builds a vector using the specified commands, ensures that the
 returned vector is ArrayVector (if no, it converts it) and then
 returns the internal representation of the vector
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharp.DataFrame.Vectors.ArrayVector.ArrayVectorBuilder.FSharp-DataFrame-Vectors-IVectorBuilder-Build``1(FSharp.DataFrame.Vectors.VectorConstruction,FSharp.DataFrame.IVector{``0}[])">
<summary>
 Given a vector construction command(s) produces a new IVector
 (the result is typically ArrayVector, but this is not guaranteed)
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharp.DataFrame.Vectors.ArrayVector.ArrayVectorBuilder">
<summary>
 Implements a builder object (`IVectorBuilder`) for creating
 vectors of type `ArrayVector&lt;&apos;T&gt;`. This includes operations such as
 appending, relocating values, creating vectors from arrays etc.
 The vector builder automatically switches between the two possible
 representations of the vector - when a missing value is present, it
 uses `ArrayVectorData.VectorOptional`, otherwise it uses 
 `ArrayVectorData.VectorNonOptional`.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharp.DataFrame.Vectors.ArrayVector.ArrayVectorData`1">
<summary>
 --------------------------------------------------------------------------------------
 ArrayVector - stores data of the vector in a continuous memory block. If the vector
 contains missing values, then uses `OptionalValue&lt;&apos;T&gt;[]`, otherwise uses just `&apos;T[]`.
 --------------------------------------------------------------------------------------
 Internal representation of the ArrayVector. To make this more 
 efficient, we distinguish between &quot;sparse&quot; vectors that have missing 
 values and &quot;dense&quot; vectors without N/As.
</summary>
</member>
</members>
</doc>
