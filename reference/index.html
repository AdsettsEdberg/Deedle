<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Namespaces - Deedle</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="BlueMountain Capital">

    <script src="https://code.jquery.com/jquery-1.8.0.js"></script>
    <script src="https://code.jquery.com/ui/1.8.23/jquery-ui.js"></script>
    <script src="https://netdna.bootstrapcdn.com/twitter-bootstrap/2.2.1/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link href="https://netdna.bootstrapcdn.com/twitter-bootstrap/2.2.1/css/bootstrap-combined.min.css" rel="stylesheet">

    <link type="text/css" rel="stylesheet" href="http://bluemountaincapital.github.io/Deedle/content/style.css" />
    <link type="text/css" rel="stylesheet" href="http://bluemountaincapital.github.io/Deedle/content/deedle.css" />
    <script type="text/javascript" src="http://bluemountaincapital.github.io/Deedle/content/tips.js"></script>
    <!-- HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="container">
      <div class="masthead">
        <ul class="nav nav-pills pull-right">
          <li><a href="http://fsharp.org">fsharp.org</a></li>
          <li><a href="http://bluemountaincapital.github.io/FSharpRProvider"><img height=" 16" width="16" src="http://fsharp.org/images/thumbs/FSharpRProvider.png" /> R Provider</a></li>
          <li><a href="http://fsharp.github.io/FSharp.Charting/"><img height="16" width="16" src="http://fsharp.org/images/thumbs/FSharp.Charting.png" /> F# Charting</a></li>
          <li><a href="http://fsharp.github.io/FSharp.Data"><img height="16" width="16" src="http://fsharp.org/images/thumbs/FSharp.Data.png" /> F# Data</a></li>
          <li><a href="http://fsprojects.github.io/FSharp.Data.Toolbox"><img height="16" width="16" src="http://fsharp.org/images/thumbs/FSharp.Data.Toolbox.png" /> F# Data Toolbox</a></li>
        </ul>
        <h3 class="muted"><a href="http://bluemountaincapital.github.io/Deedle/index.html">Deedle</a></h3>
      </div>
      <hr />
      <div class="row">
        <div class="span9" id="main">
          

<h1>Deedle</h1>

  <h2>Deedle Namespace</h2>
  <div>
      <table class="table table-bordered type-list">
    <thead>
      <tr><td>Type</td><td>Description</td></tr>
    </thead>
    <tbody>
        <tr>
          <td class="type-name">
            <a href="deedle-aggregation-1.html">Aggregation<'K></a>
          </td>
          <td class="xmldoc"><p>Represents a strategy for aggregating data in an ordered series into data segments.
To create a value of this type from C#, use the non-generic <code>Aggregation</code> type.
Data can be aggregate using floating windows or chunks of a specified size or 
by specifying a condition on two keys (i.e. end a window/chunk when the condition
no longer holds).</p>
</td>
        </tr>
        <tr>
          <td class="type-name">
            <a href="deedle-aggregation.html">Aggregation</a>
          </td>
          <td class="xmldoc"><p>A non-generic type that simplifies the construction of <code>Aggregation&lt;K&gt;</code> values
from C#. It provides methods for constructing different kinds of aggregation
strategies for ordered series.</p>
</td>
        </tr>
        <tr>
          <td class="type-name">
            <a href="deedle-boundary.html">Boundary</a>
          </td>
          <td class="xmldoc"><p>Represents boundary behaviour for operations such as floating window. The type
specifies whether incomplete windows (of smaller than required length) should be
produced at the beginning (<code>AtBeginning</code>) or at the end (<code>AtEnding</code>) or
skipped (<code>Skip</code>). For chunking, combinations are allowed too - to skip incomplete
chunk at the beginning, use <code>Boundary.Skip ||| Boundary.AtBeginning</code>.</p>
</td>
        </tr>
        <tr>
          <td class="type-name">
            <a href="deedle-columnseries-2.html">ColumnSeries<'TRowKey, 'TColumnKey></a>
          </td>
          <td class="xmldoc"></td>
        </tr>
        <tr>
          <td class="type-name">
            <a href="deedle-datasegment-1.html">DataSegment<'T></a>
          </td>
          <td class="xmldoc"><p>Represents a segment of a series or sequence. The value is returned from 
various functions that aggregate data into chunks or floating windows. The 
<code>Complete</code> case represents complete segment (e.g. of the specified size) and
<code>Boundary</code> represents segment at the boundary (e.g. smaller than the required
size).</p>
</td>
        </tr>
        <tr>
          <td class="type-name">
            <a href="deedle-datasegmentkind.html">DataSegmentKind</a>
          </td>
          <td class="xmldoc"><p>Represents a kind of <code>DataSegment&lt;T&gt;</code>. See that type for more information.</p>
</td>
        </tr>
        <tr>
          <td class="type-name">
            <a href="deedle-delayedseries.html">DelayedSeries</a>
          </td>
          <td class="xmldoc"><p>This type exposes a single static method <code>DelayedSeries.Create</code> that can be used for
constructing data series (of type <code>Series&lt;K, V&gt;</code>) with lazily loaded data. You can
use this functionality to create series that represents e.g. an entire price history
in a database, but only loads data that are actually needed. For more information
see the <a href="../lazysource.html">lazy data loading tutorial</a>.</p>
</td>
        </tr>
        <tr>
          <td class="type-name">
            <a href="deedle-direction.html">Direction</a>
          </td>
          <td class="xmldoc"><p>Specifies in which direction should we look when performing operations such as
<code>Series.Pairwise</code>.</p>
</td>
        </tr>
        <tr>
          <td class="type-name">
            <a href="deedle-enumerableextensions.html">EnumerableExtensions</a>
          </td>
          <td class="xmldoc"><p>Contains extension methods for various instances of <code>IEnumerable</code> that
can be used for creating <code>Series&lt;'K, 'V&gt;</code> from the <code>IEnumerable</code> value.</p>
</td>
        </tr>
        <tr>
          <td class="type-name">
            <a href="deedle-frame-2.html">Frame<'TRowKey, 'TColumnKey></a>
          </td>
          <td class="xmldoc"><p>A frame contains one Index, with multiple Vecs
(because this is dynamic, we need to store them as IVec)</p>
</td>
        </tr>
        <tr>
          <td class="type-name">
            <a href="deedle-frame.html">Frame</a>
          </td>
          <td class="xmldoc"><p>Provides static methods for creating frames, reading frame data
from CSV files and database (via IDataReader). The type also provides
global configuration for reflection-based expansion.</p>
</td>
        </tr>
        <tr>
          <td class="type-name">
            <a href="deedle-framedata.html">FrameData</a>
          </td>
          <td class="xmldoc"><p>Represents the underlying (raw) data of the frame in a format that can
be used for exporting data frame to other formats etc. (DataTable, CSV, Excel)</p>
</td>
        </tr>
        <tr>
          <td class="type-name">
            <a href="deedle-frameextensions.html">FrameExtensions</a>
          </td>
          <td class="xmldoc"><p>Some comment</p>
</td>
        </tr>
        <tr>
          <td class="type-name">
            <a href="deedle-icustomlookup-1.html">ICustomLookup<'K></a>
          </td>
          <td class="xmldoc"><p>Represents a special lookup. This can be used to support hierarchical or duplicate keys
in an index. A key type <code>K</code> can come with associated <code>ICustomLookup&lt;K&gt;</code> to provide 
customized pattern matching (equality testing)</p>
</td>
        </tr>
        <tr>
          <td class="type-name">
            <a href="deedle-iframe.html">IFrame</a>
          </td>
          <td class="xmldoc"><p>An empty interface that is implemented by <code>Frame&lt;'R, 'C&gt;</code>. The purpose of the
interface is to allow writing code that works on arbitrary data frames (you 
need to provide an implementation of the <code>IFrameOperation&lt;'V&gt;</code> which contains
a generic method <code>Invoke</code> that will be called with the typed data frame).</p>
</td>
        </tr>
        <tr>
          <td class="type-name">
            <a href="deedle-iframeoperation-1.html">IFrameOperation<'V></a>
          </td>
          <td class="xmldoc"><p>Represents an operation that can be invoked on <code>Frame&lt;'R, 'C&gt;</code>. The operation
is generic in the type of row and column keys.</p>
</td>
        </tr>
        <tr>
          <td class="type-name">
            <a href="deedle-iseries-1.html">ISeries<'K></a>
          </td>
          <td class="xmldoc"><p>Represents an untyped series with keys of type <code>K</code> and values of some unknown type
(This type should not generally be used directly, but it can be used when you need
to write code that works on a sequence of series of heterogeneous types).</p>
</td>
        </tr>
        <tr>
          <td class="type-name">
            <a href="deedle-ivector-1.html">IVector<'T></a>
          </td>
          <td class="xmldoc"><p>A generic, typed vector. Represents mapping from addresses to values of type <code>T</code>. 
The vector provides a minimal interface that is required by series and can be
implemented in a number of ways to provide vector backed by database or an
alternative representation of data.</p>
</td>
        </tr>
        <tr>
          <td class="type-name">
            <a href="deedle-ivector.html">IVector</a>
          </td>
          <td class="xmldoc"><p>Represents an (untyped) vector that stores some values and provides access
to the values via a generic address. This type should be only used directly when
extending the DataFrame library and adding a new way of storing or loading data.
To allow invocation via Reflection, the vector exposes type of elements as <code>System.Type</code>.</p>
</td>
        </tr>
        <tr>
          <td class="type-name">
            <a href="deedle-index.html">Index</a>
          </td>
          <td class="xmldoc"><p>Type that provides access to creating indices (represented as <code>LinearIndex</code> values)</p>
</td>
        </tr>
        <tr>
          <td class="type-name">
            <a href="deedle-joinkind.html">JoinKind</a>
          </td>
          <td class="xmldoc"><p>This enumeration specifies joining behavior for <code>Join</code> method provided
by <code>Series</code> and <code>Frame</code>. Outer join unions the keys (and may introduce
missing values), inner join takes the intersection of keys; left and
right joins take the keys of the first or the second series/frame.</p>
</td>
        </tr>
        <tr>
          <td class="type-name">
            <a href="deedle-keyvalue.html">KeyValue</a>
          </td>
          <td class="xmldoc"></td>
        </tr>
        <tr>
          <td class="type-name">
            <a href="deedle-lookup.html">Lookup</a>
          </td>
          <td class="xmldoc"><p>Represents different behaviors of key lookup in series. For unordered series,
the only available option is <code>Lookup.Exact</code> which finds the exact key - methods
fail or return missing value if the key is not available in the index. For ordered
series <code>Lookup.Greater</code> finds the first greater key (e.g. later date) with
a value. <code>Lookup.Smaller</code> searches for the first smaller key. The options
<code>Lookup.ExactOrGreater</code> and <code>Lookup.ExactOrSmaller</code> finds the exact key (if it is
present) and otherwise search for the nearest larger or smaller key, respectively.</p>
</td>
        </tr>
        <tr>
          <td class="type-name">
            <a href="deedle-missingvalueexception.html">MissingValueException</a>
          </td>
          <td class="xmldoc"><p>Thrown when a value at the specified index does not exist in the data frame or series.
This exception is thrown only when the key is defined, but the value is not available,
in other situations <code>KeyNotFoundException</code> is thrown</p>
</td>
        </tr>
        <tr>
          <td class="type-name">
            <a href="deedle-objectseries-1.html">ObjectSeries<'K></a>
          </td>
          <td class="xmldoc"></td>
        </tr>
        <tr>
          <td class="type-name">
            <a href="deedle-optionalvalue-1.html">OptionalValue<'T></a>
          </td>
          <td class="xmldoc"><p>Value type that represents a potentially missing value. This is similar to 
<code>System.Nullable&lt;T&gt;</code>, but does not restrict the contained value to be a value
type, so it can be used for storing values of any types. When obtained from
<code>DataFrame&lt;R, C&gt;</code> or <code>Series&lt;K, T&gt;</code>, the <code>Value</code> will never be <code>Double.NaN</code> or <code>null</code>
(but this is not, in general, checked when constructing the value).</p>

<p>The type is only used in C#-friendly API. F# operations generally use expose
standard F# <code>option&lt;T&gt;</code> type instead. However, there the <code>OptionalValue</code> module
contains helper functions for using this type from F# as well as <code>Missing</code> and
<code>Present</code> active patterns.</p>
</td>
        </tr>
        <tr>
          <td class="type-name">
            <a href="deedle-optionalvalue.html">OptionalValue</a>
          </td>
          <td class="xmldoc"><p>Non-generic type that makes it easier to create <code>OptionalValue&lt;T&gt;</code> values
from C# by benefiting the type inference for generic method invocations.</p>
</td>
        </tr>
        <tr>
          <td class="type-name">
            <a href="deedle-optionalvalueextensions.html">OptionalValueExtensions</a>
          </td>
          <td class="xmldoc"><p>Extension methods for working with optional values from C#. These make
it easier to provide default values and convert optional values to 
<code>Nullable</code> (when the contained value is value type)</p>
</td>
        </tr>
        <tr>
          <td class="type-name">
            <a href="deedle-rowseries-2.html">RowSeries<'TRowKey, 'TColumnKey></a>
          </td>
          <td class="xmldoc"></td>
        </tr>
        <tr>
          <td class="type-name">
            <a href="deedle-series-2.html">Series<'K, 'V></a>
          </td>
          <td class="xmldoc"><p>The type <code>Series&lt;K, V&gt;</code> represents a data series consisting of values <code>V</code> indexed by
keys <code>K</code>. The keys of a series may or may not be ordered</p>
</td>
        </tr>
        <tr>
          <td class="type-name">
            <a href="deedle-seriesbuilder-2.html">SeriesBuilder<'K, 'V></a>
          </td>
          <td class="xmldoc"><p>The type can be used for creating series using mutation. You can add 
items using <code>Add</code> and get the resulting series using the <code>Series</code> property.</p>
</td>
        </tr>
        <tr>
          <td class="type-name">
            <a href="deedle-seriesbuilder-1.html">SeriesBuilder<'K></a>
          </td>
          <td class="xmldoc"><p>A simple class that inherits from <code>SeriesBuilder&lt;'K, obj&gt;</code> and can be
used instead of writing <code>SeriesBuilder&lt;'K, obj&gt;</code> with two type arguments.</p>
</td>
        </tr>
        <tr>
          <td class="type-name">
            <a href="deedle-seriesextensions.html">SeriesExtensions</a>
          </td>
          <td class="xmldoc"></td>
        </tr>
        <tr>
          <td class="type-name">
            <a href="deedle-seriesstatsextensions.html">SeriesStatsExtensions</a>
          </td>
          <td class="xmldoc"></td>
        </tr>
        <tr>
          <td class="type-name">
            <a href="deedle-stats.html">Stats</a>
          </td>
          <td class="xmldoc"><p>The <code>Stats</code> type contains functions for fast calculation of statistics over
series and frames as well as over a moving and an expanding window in a series.</p>

<p>The resulting series has the same keys as the input series. When there are
no values, or missing values, different functions behave in different ways.
Statistics (e.g. mean) return missing value when any value is missing, while min/max
functions return the minimal/maximal element (skipping over missing values).</p>
</td>
        </tr>
        <tr>
          <td class="type-name">
            <a href="deedle-tryvalue-1.html">TryValue<'T></a>
          </td>
          <td class="xmldoc"><p>Represents a value or an exception. This type is used by functions such as
<code>Series.tryMap</code> and <code>Frame.tryMap</code> to capture the result of a lambda function,
which may be either a value or an exception. The type is a discriminated union,
so it can be processed using F# pattern matching, or using <code>Value</code>, <code>HasValue</code>
and <code>Exception</code> properties</p>
</td>
        </tr>
        <tr>
          <td class="type-name">
            <a href="deedle-unionbehavior.html">UnionBehavior</a>
          </td>
          <td class="xmldoc"><p>This enumeration specifeis the behavior of <code>Union</code> operation on series when there are
overlapping keys in two series that are being unioned. The options include prefering values
from the left/right series or throwing an exception when both values are available.</p>
</td>
        </tr>
        <tr>
          <td class="type-name">
            <a href="deedle-vectorcallsite-1.html">VectorCallSite<'R></a>
          </td>
          <td class="xmldoc"><p>Represents a generic function <code>\forall.'T.(IVector&lt;'T&gt; -&gt; 'R)</code>. The function can be 
generically invoked on an argument of type <code>IVector</code> using <code>IVector.Invoke</code></p>
</td>
        </tr>
        <tr>
          <td class="type-name">
            <a href="deedle-opt-1.html">opt<'T></a>
          </td>
          <td class="xmldoc"><p>A type alias for the <code>OptionalValue&lt;T&gt;</code> type. The type alias can be used
to make F# type definitions that use optional values directly more succinct.</p>
</td>
        </tr>
        <tr>
          <td class="type-name">
            <a href="deedle-tryval-1.html">tryval<'T></a>
          </td>
          <td class="xmldoc"><p>A type alias for the <code>TryValue&lt;T&gt;</code> type. The type alias can be used
to make F# type declarations that explcitly handle exceptions more succinct.</p>
</td>
        </tr>
    </tbody>
  </table>
  <table class="table table-bordered module-list">
    <thead>
      <tr><td>Module</td><td>Description</td></tr>
    </thead>
    <tbody>
        <tr>
          <td class="module-name">
            <a href="deedle-addressing.html">Addressing</a>
          </td>
          <td class="xmldoc"><p>An <code>Address</code> value is used as an interface between vectors and indices. The index maps
keys of various types to address, which is then used to get a value from the vector.
In the current implementation, the address is just <code>int64</code>, but most address-related
functionality is in a separate module to make this easy to change.</p>
</td>
        </tr>
        <tr>
          <td class="module-name">
            <a href="deedle-datasegment.html">DataSegment</a>
          </td>
          <td class="xmldoc"><p>Provides helper functions and active patterns for working with <code>DataSegment</code> values</p>
</td>
        </tr>
        <tr>
          <td class="module-name">
            <a href="deedle-fsharpframeextensions.html">FSharpFrameExtensions</a>
          </td>
          <td class="xmldoc"></td>
        </tr>
        <tr>
          <td class="module-name">
            <a href="deedle-fsharpindexbuilderimplementation.html">FSharpIndexBuilderImplementation</a>
          </td>
          <td class="xmldoc"><p>Set concrete IIndexBuilder implementation</p>
</td>
        </tr>
        <tr>
          <td class="module-name">
            <a href="deedle-fsharpindexextensions.html">FSharpIndexExtensions</a>
          </td>
          <td class="xmldoc"><p>Defines non-generic <code>Index</code> type that provides functions for building indices
(hard-bound to <code>LinearIndexBuilder</code> type). In F#, the module is automatically opened
using <code>AutoOpen</code>. The methods are not designed for the use from C#.</p>
</td>
        </tr>
        <tr>
          <td class="module-name">
            <a href="deedle-fsharpseriesextensions.html">FSharpSeriesExtensions</a>
          </td>
          <td class="xmldoc"><p>Contains extensions for creating values of type <code>Series&lt;'K, 'V&gt;</code> including
a type with functions such as <code>Series.ofValues</code> and the <code>series</code> function.
The module is automatically opened for all F# code that references <code>Deedle</code>.</p>
</td>
        </tr>
        <tr>
          <td class="module-name">
            <a href="deedle-fsharpvectorbuilderimplementation.html">FSharpVectorBuilderImplementation</a>
          </td>
          <td class="xmldoc"><p>Set concrete IVectorBuilder implementation</p>
</td>
        </tr>
        <tr>
          <td class="module-name">
            <a href="deedle-fsharpvectorextensions.html">FSharpVectorExtensions</a>
          </td>
          <td class="xmldoc"><p>Defines non-generic <code>Vector</code> type that provides functions for building vectors
(hard-bound to <code>ArrayVectorBuilder</code> type). In F#, the module is automatically opened
using <code>AutoOpen</code>. The methods are not designed for the use from C#.</p>
</td>
        </tr>
        <tr>
          <td class="module-name">
            <a href="deedle-framemodule.html">Frame</a>
          </td>
          <td class="xmldoc"><p>The <code>Frame</code> module provides an F#-friendly API for working with data frames. 
The module follows the usual desing for collection-processing in F#, so the 
functions work well with the pipelining operator (<code>|&gt;</code>). For example, given
a frame with two columns representing prices, we can use <code>Frame.diff</code> and 
numerical operators to calculate daily returns like this:</p>

<pre><code>let df = frame [ "MSFT" =&gt; prices1; "AAPL" =&gt; prices2 ]
let past = df |&gt; Frame.diff 1
let rets = past / df * 100.0
rets |&gt; Stats.mean
</code></pre>

<p>Note that the <code>Stats.mean</code> operation is overloaded and works both on series 
(returning a number) and on frames (returning a series).</p>

<p>The functions in this module are designed to be used from F#. For a C#-friendly
API, see the <code>FrameExtensions</code> type. For working with individual series, see the
<code>Series</code> module. The functions in the <code>Frame</code> module are grouped in a number of 
categories and documented below.</p>
</td>
        </tr>
        <tr>
          <td class="module-name">
            <a href="deedle-framebuilder.html">FrameBuilder</a>
          </td>
          <td class="xmldoc"></td>
        </tr>
        <tr>
          <td class="module-name">
            <a href="deedle-multikeyextensions.html">MultiKeyExtensions</a>
          </td>
          <td class="xmldoc"><p>F#-friendly functions for creating multi-level keys and lookups</p>
</td>
        </tr>
        <tr>
          <td class="module-name">
            <a href="deedle-optionalvaluemodule.html">OptionalValue</a>
          </td>
          <td class="xmldoc"><p>Provides various helper functions for using the <code>OptionalValue&lt;T&gt;</code> type from F#
(The functions are similar to those in the standard <code>Option</code> module).</p>
</td>
        </tr>
        <tr>
          <td class="module-name">
            <a href="deedle-pair.html">Pair</a>
          </td>
          <td class="xmldoc"><p>Module with helper functions for extracting values from hierarchical tuples</p>
</td>
        </tr>
        <tr>
          <td class="module-name">
            <a href="deedle-seriesmodule.html">Series</a>
          </td>
          <td class="xmldoc"><p>The <code>Series</code> module provides an F#-friendly API for working with data and time series. 
The API follows the usual design for collection-processing in F#, so the functions work
well with the pipelining (<code>|&gt;</code>) operator. For example, given a series with ages,
we can use <code>Series.filterValues</code> to filter outliers and then <code>Stats.mean</code> to calculate
the mean:</p>

<pre><code>ages
|&gt; Series.filterValues (fun v -&gt; v &gt; 0.0 &amp;&amp; v &lt; 120.0)
|&gt; Stats.mean
</code></pre>

<p>The module provides comprehensive set of functions for working with series. The same
API is also exposed using C#-friendly extension methods. In C#, the above snippet could
be written as:</p>

<pre><code>[lang=csharp]
ages
  .Where(kvp =&gt; kvp.Value &gt; 0.0 &amp;&amp; kvp.Value &lt; 120.0)
  .Mean()
</code></pre>

<p>For more information about similar frame-manipulation functions, see the <code>Frame</code> module.
For more information about C#-friendly extensions, see <code>SeriesExtensions</code>. The functions 
in the <code>Series</code> module are grouped in a number of categories and documented below.</p>
</td>
        </tr>
        <tr>
          <td class="module-name">
            <a href="deedle-vectorextensions.html">VectorExtensions</a>
          </td>
          <td class="xmldoc"><p>Module with extensions for generic vector type. Given <code>vec</code> of type <code>IVector&lt;T&gt;</code>, 
the extension property <code>vec.DataSequence</code> returns all data of the vector converted
to the "least common denominator" data structure - <code>IEnumerable&lt;T&gt;</code>.</p>
</td>
        </tr>
    </tbody>
  </table>

  </div>
  <h2>Deedle.Indices Namespace</h2>
  <div>
      <table class="table table-bordered type-list">
    <thead>
      <tr><td>Type</td><td>Description</td></tr>
    </thead>
    <tbody>
        <tr>
          <td class="type-name">
            <a href="deedle-indices-asyncseriesconstruction-1.html">AsyncSeriesConstruction<'K></a>
          </td>
          <td class="xmldoc"><p>Asynchronous version of <code>SeriesConstruction&lt;'K&gt;</code>. Returns a workflow that evaluates
the index, together with a construction to apply (asynchronously) on vectors</p>
</td>
        </tr>
        <tr>
          <td class="type-name">
            <a href="deedle-indices-boundarybehavior.html">BoundaryBehavior</a>
          </td>
          <td class="xmldoc"><p>Specifies the boundary behavior for the <code>IIndexBuilder.GetRange</code> operation
(whether the boundary elements should be included or not)</p>
</td>
        </tr>
        <tr>
          <td class="type-name">
            <a href="deedle-indices-iindex-1.html">IIndex<'K></a>
          </td>
          <td class="xmldoc"><p>An interface that represents index mapping keys of some generic type <code>T</code> to locations
of address <code>Address</code>. The <code>IIndex&lt;K&gt;</code> contains minimal set of operations that have to
be supported by an index. This type should be only used directly when
extending the DataFrame library and adding a new way of storing or loading data.
Values of this type are constructed using the associated <code>IIndexBuilder</code> type.</p>
</td>
        </tr>
        <tr>
          <td class="type-name">
            <a href="deedle-indices-iindexbuilder.html">IIndexBuilder</a>
          </td>
          <td class="xmldoc"><p>A builder represents various ways of constructing index, either from keys or from
other indices. The operations that build a new index from an existing index also 
build <code>VectorConstruction</code> which specifies how to transform vectors aligned with the
previous index to match the new index. The methods generally take <code>VectorConstruction</code>
as an input, apply necessary transformations to it and return a new <code>VectorConstruction</code>.</p>
</td>
        </tr>
        <tr>
          <td class="type-name">
            <a href="deedle-indices-seriesconstruction-1.html">SeriesConstruction<'K></a>
          </td>
          <td class="xmldoc"><p>Represents a pair of index and vector construction 
(many of the index operations take/return an index together with a construction
command that builds a vector matching with the index, so this type alias
makes this more obvious)</p>
</td>
        </tr>
    </tbody>
  </table>

  </div>
  <h2>Deedle.Indices.Linear Namespace</h2>
  <div>
      <table class="table table-bordered type-list">
    <thead>
      <tr><td>Type</td><td>Description</td></tr>
    </thead>
    <tbody>
        <tr>
          <td class="type-name">
            <a href="deedle-indices-linear-linearindex-1.html">LinearIndex<'K></a>
          </td>
          <td class="xmldoc"><p>An index that maps keys <code>K</code> to offsets <code>Address</code>. The keys cannot be duplicated.
The construction checks if the keys are ordered (using the provided or the default
comparer for <code>K</code>) and disallows certain operations on unordered indices.</p>
</td>
        </tr>
        <tr>
          <td class="type-name">
            <a href="deedle-indices-linear-linearindexbuilder.html">LinearIndexBuilder</a>
          </td>
          <td class="xmldoc"><p>Index builder object that is associated with <code>LinearIndex&lt;K&gt;</code> type. The builder
provides operations for manipulating linear indices (and the associated vectors).</p>
</td>
        </tr>
        <tr>
          <td class="type-name">
            <a href="deedle-indices-linear-linearrangeindex-1.html">LinearRangeIndex<'K></a>
          </td>
          <td class="xmldoc"><p>A virtual index that represents a subrange of a specified index. This is useful for
windowing operations where we do not want to allocate a new index for each window. 
This index can be cheaply constructed and it implements many of the standard functions
without actually allocating the index (e.g. KeyCount, KeyAt, IsEmpty). For more 
complex index manipulations (including lookup), an actual index is constructed lazily.</p>
</td>
        </tr>
    </tbody>
  </table>

  </div>
  <h2>Deedle.Internal Namespace</h2>
  <div>
      <table class="table table-bordered type-list">
    <thead>
      <tr><td>Type</td><td>Description</td></tr>
    </thead>
    <tbody>
        <tr>
          <td class="type-name">
            <a href="deedle-internal-binomialheap-1.html">BinomialHeap<'T></a>
          </td>
          <td class="xmldoc"><p>Binomial heap stores a list of trees together with custom comparer</p>
</td>
        </tr>
        <tr>
          <td class="type-name">
            <a href="deedle-internal-comparisonfailedexception.html">ComparisonFailedException</a>
          </td>
          <td class="xmldoc"><p>An internal exception that is used to handle the case when comparison fails
(even though the type implements IComparable and everything...)</p>
</td>
        </tr>
        <tr>
          <td class="type-name">
            <a href="deedle-internal-deque-1.html">Deque<'T></a>
          </td>
          <td class="xmldoc"><p>Mutable double ended queue that holds elements in a circular array.
The data structure provides O(1) RemoveFirst and RemoveLast. Add is 
O(1) when the deque has enough internal capacity, otherwise it extends
the array 2x (so amortized cost is O(1) too).</p>
</td>
        </tr>
        <tr>
          <td class="type-name">
            <a href="deedle-internal-rankedtree-1.html">RankedTree<'T></a>
          </td>
          <td class="xmldoc"><p>Tree where nodes contain values and zero or more child trees.
For each node, we store rank - the number of children</p>
</td>
        </tr>
    </tbody>
  </table>
  <table class="table table-bordered module-list">
    <thead>
      <tr><td>Module</td><td>Description</td></tr>
    </thead>
    <tbody>
        <tr>
          <td class="module-name">
            <a href="deedle-internal-array.html">Array</a>
          </td>
          <td class="xmldoc"><p>This module contains additional functions for working with arrays. 
<code>Deedle.Internals</code> is opened, it extends the standard <code>Array</code> module.</p>
</td>
        </tr>
        <tr>
          <td class="module-name">
            <a href="deedle-internal-binomialheap.html">BinomialHeap</a>
          </td>
          <td class="xmldoc"><p>Module with functions for working with binomial heaps</p>
</td>
        </tr>
        <tr>
          <td class="module-name">
            <a href="deedle-internal-missingvalues.html">MissingValues</a>
          </td>
          <td class="xmldoc"><p>Utility functions for identifying missing values. The <code>isNA</code> function 
can be used to test whether a value represents a missing value - this includes
the <code>null</code> value, <code>Nullable&lt;T&gt;</code> value with <code>HasValue = false</code> and 
<code>Single.NaN</code> as well as <code>Double.NaN</code>.</p>

<p>The functions in this module are not intended to be called directly.</p>
</td>
        </tr>
        <tr>
          <td class="module-name">
            <a href="deedle-internal-readonlycollection.html">ReadOnlyCollection</a>
          </td>
          <td class="xmldoc"><p>Provides helper functions for working with <code>ReadOnlyCollection&lt;T&gt;</code> similar to those 
in the <code>Array</code> module. Most importantly, F# 3.0 does not know that array implements
<code>IList&lt;T&gt;</code>.</p>
</td>
        </tr>
        <tr>
          <td class="module-name">
            <a href="deedle-internal-readonlycollectionextensions.html">ReadOnlyCollectionExtensions</a>
          </td>
          <td class="xmldoc"></td>
        </tr>
        <tr>
          <td class="module-name">
            <a href="deedle-internal-seq.html">Seq</a>
          </td>
          <td class="xmldoc"><p>This module contains additional functions for working with sequences. 
<code>Deedle.Internals</code> is opened, it extends the standard <code>Seq</code> module.</p>
</td>
        </tr>
    </tbody>
  </table>

  </div>
  <h2>Deedle.Keys Namespace</h2>
  <div>
      <table class="table table-bordered type-list">
    <thead>
      <tr><td>Type</td><td>Description</td></tr>
    </thead>
    <tbody>
        <tr>
          <td class="type-name">
            <a href="deedle-keys-customkey.html">CustomKey</a>
          </td>
          <td class="xmldoc"><p>Helper type that can be used to get <code>ICustomKey</code> for any object (including objects
that actually implement the interface and tuples)</p>
</td>
        </tr>
        <tr>
          <td class="type-name">
            <a href="deedle-keys-icustomkey.html">ICustomKey</a>
          </td>
          <td class="xmldoc"><p>Represents a special hierarchical key. This is mainly used in pretty printing (where we want to 
get parts of the keys based on levels. <code>CustomKey.Get</code> provides a way of getting <code>ICustomKey</code>.</p>
</td>
        </tr>
        <tr>
          <td class="type-name">
            <a href="deedle-keys-simplelookup-1.html">SimpleLookup<'T></a>
          </td>
          <td class="xmldoc"><p>Implements a simple lookup that matches any multi-level key against a specified array of
optional objects (that represent missing/set parts of a key)</p>
</td>
        </tr>
    </tbody>
  </table>

  </div>
  <h2>Deedle.Vectors Namespace</h2>
  <div>
      <table class="table table-bordered type-list">
    <thead>
      <tr><td>Type</td><td>Description</td></tr>
    </thead>
    <tbody>
        <tr>
          <td class="type-name">
            <a href="deedle-vectors-ivectorbuilder.html">IVectorBuilder</a>
          </td>
          <td class="xmldoc"><p>Represents an object that can construct vector values by processing 
the "mini-DSL" representation <code>VectorConstruction</code>.</p>
</td>
        </tr>
        <tr>
          <td class="type-name">
            <a href="deedle-vectors-ivectorvaluelisttransform.html">IVectorValueListTransform</a>
          </td>
          <td class="xmldoc"><p>Represent a tranformation that is applied when combining N vectors</p>
</td>
        </tr>
        <tr>
          <td class="type-name">
            <a href="deedle-vectors-ivectorvaluetransform.html">IVectorValueTransform</a>
          </td>
          <td class="xmldoc"><p>Represent a transformation that is applied when combining two vectors
(because we are combining untyped <code>IVector</code> values, the transformation
is also untyped)</p>
</td>
        </tr>
        <tr>
          <td class="type-name">
            <a href="deedle-vectors-vector.html">Vector</a>
          </td>
          <td class="xmldoc"><p>Type that provides access to creating vectors (represented as arrays)</p>
</td>
        </tr>
        <tr>
          <td class="type-name">
            <a href="deedle-vectors-vectorconstruction.html">VectorConstruction</a>
          </td>
          <td class="xmldoc"><p>A "mini-DSL" that describes construction of a vector. Vector can be constructed
from various range operations (relocate, drop, slicing, appending), by combination
of two vectors or by taking a vector from a list of variables.</p>

<p>Notably, vectors can only be constructed from other vectors of the same type 
(the <code>Combine</code> operation requires this - even though that one could be made more general).
This is an intentional choice to make the representation simpler.</p>

<p>Logically, when we apply some index operation, we should get back a polymorphic vector
construction (<code>\forall T. VectorConstruction&lt;T&gt;</code>) that can be applied to variuous 
different vector types. That would mean adding some more types, so we just model vector
construction as an untyped operation and the typing is resquired by the <code>Build</code> method
of the vector builder.</p>
</td>
        </tr>
        <tr>
          <td class="type-name">
            <a href="deedle-vectors-vectordata-1.html">VectorData<'T></a>
          </td>
          <td class="xmldoc"><p>Provides a way to get the data of an arbitrary vector. This is a concrete type used 
by functions that operate on vectors (like <code>Series.sum</code>, etc.). The vector may choose
to return the data as <code>ReadOnlyCollection</code> (with or without N/A values) which is more
efficient to use or as a lazy sequence (slower, but more general).</p>
</td>
        </tr>
        <tr>
          <td class="type-name">
            <a href="deedle-vectors-vectorfillmissing.html">VectorFillMissing</a>
          </td>
          <td class="xmldoc"><p>Specifies how to fill missing values in a vector (when using the 
<code>VectorConstruction.FillMissing</code> command). This can only fill missing
values using strategy that does not require access to index keys - 
either using constant or by propagating values.</p>
</td>
        </tr>
        <tr>
          <td class="type-name">
            <a href="deedle-vectors-vectorhole.html">VectorHole</a>
          </td>
          <td class="xmldoc"><p>Representes a "variable" in the mini-DSL below</p>
</td>
        </tr>
        <tr>
          <td class="type-name">
            <a href="deedle-vectors-vectorrange.html">VectorRange</a>
          </td>
          <td class="xmldoc"><p>Represents a range inside a vector</p>
</td>
        </tr>
    </tbody>
  </table>

  </div>
  <h2>Deedle.Vectors.ArrayVector Namespace</h2>
  <div>
      <table class="table table-bordered type-list">
    <thead>
      <tr><td>Type</td><td>Description</td></tr>
    </thead>
    <tbody>
        <tr>
          <td class="type-name">
            <a href="deedle-vectors-arrayvector-arrayvector-1.html">ArrayVector<'T></a>
          </td>
          <td class="xmldoc"><hr />

<p>Vector that stores data in an array. The data is stored using the
<code>ArrayVectorData&lt;'T&gt;</code> type (discriminated union)</p>
</td>
        </tr>
        <tr>
          <td class="type-name">
            <a href="deedle-vectors-arrayvector-arrayvectorbuilder.html">ArrayVectorBuilder</a>
          </td>
          <td class="xmldoc"><p>Implements a builder object (<code>IVectorBuilder</code>) for creating
vectors of type <code>ArrayVector&lt;'T&gt;</code>. This includes operations such as
appending, relocating values, creating vectors from arrays etc.
The vector builder automatically switches between the two possible
representations of the vector - when a missing value is present, it
uses <code>ArrayVectorData.VectorOptional</code>, otherwise it uses 
<code>ArrayVectorData.VectorNonOptional</code>.</p>
</td>
        </tr>
    </tbody>
  </table>

  </div>

        </div>
        <div class="span3">
          <a href="http://bluemountaincapital.github.io/Deedle/index.html">
            <img src="http://bluemountaincapital.github.io/Deedle/images/logo.png" style="width:140px;height:140px;margin:10px 0px 0px 35px;border-style:none;" />
          </a>

          <ul class="nav nav-list" id="menu">
            <li class="nav-header">Deedle</li>
            <li><a href="http://bluemountaincapital.github.io/Deedle/index.html">Home page</a></li>
            <li class="divider"></li>
            <li><a href="https://nuget.org/packages/Deedle">Get Library via NuGet</a></li>
            <li><a href="http://github.com/BlueMountainCapital/Deedle">Source Code on GitHub</a></li>
            <li><a href="http://github.com/BlueMountainCapital/Deedle/blob/master/LICENSE.md">License (BSD)</a></li>
            <li><a href="http://github.com/BlueMountainCapital/Deedle/blob/master/RELEASE_NOTES.md">Release notes</a></li>
            <li><a href="http://bluemountaincapital.github.io/Deedle/design.html">Design notes</a></li>
            <li><a href="http://stackoverflow.com/questions/tagged/deedle">Ask a question!</a></li>
            
            <li class="nav-header">Using from F#</li>
            <li>
              <a href="http://bluemountaincapital.github.io/Deedle/tutorial.html">Quick start tutorial</a>
            </li>
            <li>
              <a href="http://bluemountaincapital.github.io/Deedle/series.html">Working with time series</a>
            </li>
            <li>
              <a href="http://bluemountaincapital.github.io/Deedle/frame.html">Working with data frames</a>
            </li>
            <li>
              <a href="http://bluemountaincapital.github.io/Deedle/stats.html">Statistics &amp; calculations</a>
            </li>
            <li>
              <a href="http://bluemountaincapital.github.io/Deedle/rinterop.html">Using Deedle with R</a>
            </li>

            <li class="nav-header">Using from C#</li>
            <li><a href="http://bluemountaincapital.github.io/Deedle/csharpintro.html">Getting started</a></li>
            <li>
              <a href="http://bluemountaincapital.github.io/Deedle/csharpseries.html">Working with data series</a>
            </li>
            <li>
              <a href="http://bluemountaincapital.github.io/Deedle/csharpframe.html">Working with data frames</a>
            </li>

            <li class="nav-header">Documentation</li>
            <li><a href="http://bluemountaincapital.github.io/Deedle/reference/index.html">API Reference</a></li>
            <li class="divider"></li>
            <li><a href="http://bluemountaincapital.github.io/Deedle/reference/deedle-seriesmodule.html">Series module</a></li>
            <li><a href="http://bluemountaincapital.github.io/Deedle/reference/deedle-framemodule.html">Frame module</a></li>
            <li><a href="http://bluemountaincapital.github.io/Deedle/reference/deedle-stats.html">Stats module</a></li>

            <li class="nav-header">Samples</li>
            <li><a href="http://bluemountaincapital.github.io/Deedle/lazysource.html">Lazy data loading</a></li>
          </ul>
        </div>
      </div>
    </div>
    <a href="http://github.com/BlueMountainCapital/Deedle"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_right_gray_6d6d6d.png" alt="Fork me on GitHub"></a>
    <script>
      (function (i, s, o, g, r, a, m) {
        i['GoogleAnalyticsObject'] = r; i[r] = i[r] || function () {
          (i[r].q = i[r].q || []).push(arguments)
        }, i[r].l = 1 * new Date(); a = s.createElement(o),
        m = s.getElementsByTagName(o)[0]; a.async = 1; a.src = g; m.parentNode.insertBefore(a, m)
      })(window, document, 'script', '//www.google-analytics.com/analytics.js', 'ga');
      ga('create', 'UA-45379232-1', 'bluemountaincapital.github.io');
      ga('send', 'pageview');
    </script>
  </body>
</html>